<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>GainLab â€” Agent's Eyes for Financial Charts</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="sample-data.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=DM+Sans:wght@400;500;600;700&family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root{--bg:#08081a;--bg2:#0d0d1f;--card:#12122b;--bdr:#1e1e3d;--bdr-a:#00d4aa55;--up:#00d4aa;--dn:#ff4757;--acc:#5b8ff9;--gold:#ffc233;--purp:#7c4dff;--txt:#e8e8f0;--dim:#8888aa;--mut:#555577;--grid:#1a1a35;--f:'DM Sans','Noto Sans SC',sans-serif;--m:'JetBrains Mono',monospace}
    *{margin:0;padding:0;box-sizing:border-box}body{background:var(--bg);color:var(--txt);font-family:var(--f);min-height:100vh}
    .hero{text-align:center;padding:56px 20px 36px;position:relative}
    .hero::before{content:'';position:absolute;top:-40%;left:50%;transform:translateX(-50%);width:700px;height:700px;background:radial-gradient(ellipse,#00d4aa08,transparent 70%);pointer-events:none}
    .logo{font-size:3em;font-weight:700;letter-spacing:-1px}.logo .g{color:var(--up)}
    .sub{font-size:1.1em;color:var(--dim);margin:4px 0;font-weight:500}
    .tag{font-size:.88em;color:var(--mut);font-style:italic;margin-bottom:22px}
    .stats{display:flex;gap:22px;justify-content:center;flex-wrap:wrap;margin-bottom:28px;font-family:var(--m);font-size:.82em}
    .stats .s{display:flex;align-items:center;gap:5px}.stats .d{width:7px;height:7px;border-radius:50%;display:inline-block}
    .stats .d.g{background:var(--up);box-shadow:0 0 6px var(--up)}.stats .d.b{background:var(--acc);box-shadow:0 0 6px var(--acc)}.stats .d.y{background:var(--gold);box-shadow:0 0 6px var(--gold)}
    .stats .n{color:var(--txt);font-weight:600}.stats .l{color:var(--mut)}
    .tnav{display:flex;justify-content:center;gap:4px;padding:0 16px;margin-bottom:18px}
    .tb{background:0;border:1px solid var(--bdr);color:var(--dim);padding:9px 18px;border-radius:7px;font-family:var(--f);font-size:.84em;font-weight:600;cursor:pointer;transition:.2s}
    .tb:hover{background:#1a1a3a;color:var(--txt)}.tb.on{background:var(--card);border-color:var(--bdr-a);color:var(--up)}
    .demo{max-width:1060px;margin:0 auto;padding:0 16px}
    .pnl{display:none;background:var(--card);border:1px solid var(--bdr);border-radius:14px;overflow:hidden}.pnl.on{display:block}
    .ctl{display:flex;gap:8px;padding:12px 16px;flex-wrap:wrap;align-items:center;border-bottom:1px solid var(--bdr)}
    .ctl select,.ctl button{background:var(--bg);color:var(--txt);border:1px solid var(--bdr);padding:6px 12px;border-radius:6px;font-family:var(--f);font-size:.82em;cursor:pointer;transition:.2s}
    .ctl select:hover,.ctl button:hover{border-color:var(--up)}
    .ctl .go{background:var(--up);color:var(--bg);font-weight:700;border:none;padding:6px 16px}.ctl .go:hover{opacity:.85}
    .ctl .sp{flex:1}.ctl .st{font-family:var(--m);font-size:.74em;color:var(--mut)}
    .cw{width:100%;height:480px;padding:8px}
    .code-s{max-width:1060px;margin:38px auto 0;padding:0 16px}
    .code-s h3{font-size:.82em;color:var(--dim);margin-bottom:10px;font-weight:600;text-transform:uppercase;letter-spacing:1px}
    .cb{background:var(--card);border:1px solid var(--bdr);border-radius:10px;padding:16px 20px;font-family:var(--m);font-size:.78em;line-height:1.6;color:var(--dim);overflow-x:auto;white-space:pre}
    .cb .k{color:var(--purp)}.cb .s{color:var(--up)}.cb .c{color:var(--mut);font-style:italic}.cb .n{color:var(--gold)}
    .feats{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:14px;max-width:1060px;margin:40px auto 0;padding:0 16px}
    .ft{background:var(--card);border:1px solid var(--bdr);border-radius:12px;padding:20px 16px;transition:.2s}
    .ft:hover{border-color:var(--bdr-a);transform:translateY(-2px)}
    .ft .i{font-size:1.5em;margin-bottom:6px}.ft h4{font-size:.9em;margin-bottom:3px}.ft p{font-size:.76em;color:var(--mut);line-height:1.5}
    .ft .tg{display:inline-block;margin-top:7px;font-size:.66em;font-family:var(--m);padding:2px 7px;border-radius:4px}
    .ft .tg.lv{background:#00d4aa18;color:var(--up)}.ft .tg.sn{background:#5b8ff918;color:var(--acc)}
    .arch-s{max-width:1060px;margin:40px auto 0;padding:0 16px}
    .arch-s h3{font-size:.82em;color:var(--dim);margin-bottom:12px;font-weight:600;text-transform:uppercase;letter-spacing:1px}
    .arch{background:var(--card);border:1px solid var(--bdr);border-radius:12px;padding:22px;font-family:var(--m);font-size:.76em;line-height:1.8;color:var(--dim);white-space:pre;overflow-x:auto}
    .ftr{text-align:center;padding:48px 20px 28px;color:var(--mut);font-size:.82em}
    .ftr a{color:var(--acc);text-decoration:none}.ftr a:hover{text-decoration:underline}.ftr .lk{margin-bottom:8px}.ftr .lk a{margin:0 10px}
    .mkt{background:var(--bg);color:var(--up);border:1px solid var(--up);font-weight:700;font-size:.78em;padding:5px 10px;border-radius:5px}
    .mkt option{color:var(--txt);background:var(--bg)}
    .badge{display:inline-block;font-size:.62em;font-family:var(--m);padding:1px 6px;border-radius:3px;vertical-align:middle;margin-left:4px}
    .badge.live{background:#00d4aa20;color:var(--up)}.badge.sample{background:#ffc23320;color:var(--gold)}
    .lang-sw{position:absolute;top:16px;right:20px;display:flex;gap:4px;z-index:100}
    .lb{background:0;border:1px solid var(--bdr);color:var(--dim);padding:4px 10px;border-radius:5px;font-size:.78em;cursor:pointer;transition:.2s}
    .lb:hover{background:#1a1a3a;border-color:var(--up)}
    .lb.on{background:var(--card);border-color:var(--bdr-a);color:var(--up)}
    /* ===== AI Chat Panel â€” Desktop Sidebar + Mobile Tab ===== */
    #p-chat { overflow: visible; }
    .chat-main { display: flex; height: 580px; }
    .chat-chart-main { flex: 1 1 75%; min-width: 0; display: flex; flex-direction: column; background: var(--bg); border-right: 1px solid var(--bdr); }
    .chat-chart-wrap { flex: 1; position: relative; min-height: 0; }
    .chat-chart-empty { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: none; }
    .chat-chart-status { padding: 6px 12px; font-size: .78em; font-family: var(--m); color: var(--dim); border-top: 1px solid var(--bdr); min-height: 28px; }
    .chat-sidebar { flex: 0 0 280px; min-width: 240px; max-width: 320px; display: flex; flex-direction: column; background: var(--bg2); }
    .chat-sidebar-header { padding: 10px 12px; border-bottom: 1px solid var(--bdr); font-size: .88em; }
    .chat-messages { flex: 1; overflow-y: auto; padding: 10px 10px; display: flex; flex-direction: column; gap: 8px; scroll-behavior: smooth; }
    .chat-messages::-webkit-scrollbar { width: 3px; }
    .chat-messages::-webkit-scrollbar-track { background: transparent; }
    .chat-messages::-webkit-scrollbar-thumb { background: var(--bdr); border-radius: 2px; }
    .chat-msg { max-width: 95%; padding: 8px 10px; border-radius: 8px; font-size: .8em; line-height: 1.5; word-break: break-word; }
    .chat-msg.user { align-self: flex-end; background: var(--card); border: 1px solid var(--up); border-radius: 8px 8px 2px 8px; }
    .chat-msg.ai { align-self: flex-start; background: var(--card); border: 1px solid var(--acc); border-radius: 8px 8px 8px 2px; }
    .chat-msg .chat-msg-label { font-size: .7em; color: var(--mut); margin-bottom: 3px; font-weight: 600; }
    .chat-msg.user .chat-msg-label { color: var(--up); }
    .chat-msg.ai .chat-msg-label { color: var(--acc); }
    .chat-typing { display: flex; gap: 4px; align-items: center; padding: 2px 0; }
    .chat-typing span { width: 5px; height: 5px; border-radius: 50%; background: var(--acc); display: inline-block; animation: chatdot 1.2s infinite; }
    .chat-typing span:nth-child(2) { animation-delay: .2s; }
    .chat-typing span:nth-child(3) { animation-delay: .4s; }
    @keyframes chatdot { 0%,80%,100% { opacity: .2; transform: scale(.8); } 40% { opacity: 1; transform: scale(1); } }
    .chat-tool-tag { display: inline-flex; align-items: center; gap: 4px; margin-top: 5px; padding: 3px 7px; background: #5b8ff918; border: 1px solid var(--acc); border-radius: 4px; font-size: .7em; font-family: var(--m); color: var(--acc); }
    .chat-tool-tag .tt-name { font-weight: 700; }
    .chat-tool-tag .tt-params { color: var(--dim); font-size: .88em; }
    .chat-tool-status { font-size: .72em; color: var(--dim); margin-top: 4px; font-style: italic; }
    .chat-presets { padding: 8px 10px; display: flex; flex-wrap: wrap; gap: 4px; border-top: 1px solid var(--bdr); }
    .chat-preset-btn { background: var(--bg); color: var(--dim); border: 1px solid var(--bdr); padding: 4px 8px; border-radius: 12px; font-family: var(--f); font-size: .7em; cursor: pointer; transition: .18s; white-space: nowrap; }
    .chat-preset-btn:hover { border-color: var(--up); color: var(--txt); background: #1a1a3a; transform: translateY(-1px); }
    .chat-preset-btn:disabled { opacity: .5; cursor: not-allowed; transform: none; }
    .chat-input-row { display: flex; gap: 5px; padding: 8px 10px; border-top: 1px solid var(--bdr); background: var(--bg2); }
    .chat-input { flex: 1; background: var(--bg); color: var(--txt); border: 1px solid var(--bdr); padding: 7px 10px; border-radius: 6px; font-family: var(--f); font-size: .8em; outline: none; transition: .18s; }
    .chat-input:focus { border-color: var(--acc); }
    .chat-input::placeholder { color: var(--mut); }
    .chat-input:disabled { opacity: .5; }
    .chat-send-btn { background: var(--acc); color: #fff; border: none; padding: 7px 14px; border-radius: 6px; font-family: var(--f); font-size: .8em; font-weight: 700; cursor: pointer; transition: .18s; white-space: nowrap; }
    .chat-send-btn:hover { opacity: .85; }
    .chat-send-btn:disabled { opacity: .5; cursor: not-allowed; }
    .chat-toolbar { display: flex; align-items: center; gap: 6px; padding: 8px 12px; border-bottom: 1px solid var(--bdr); background: var(--bg2); flex-wrap: wrap; }
    .chat-toolbar select { background: var(--bg); color: var(--txt); border: 1px solid var(--bdr); padding: 4px 8px; border-radius: 5px; font-family: var(--f); font-size: .78em; cursor: pointer; }
    .chat-toolbar select:hover { border-color: var(--up); }
    .chat-tf-group { display: flex; gap: 2px; }
    .chat-tf-btn { background: var(--bg); color: var(--dim); border: 1px solid var(--bdr); padding: 3px 10px; font-family: var(--m); font-size: .74em; cursor: pointer; transition: .15s; }
    .chat-tf-btn:first-child { border-radius: 4px 0 0 4px; }
    .chat-tf-btn:last-child { border-radius: 0 4px 4px 0; }
    .chat-tf-btn.on { background: var(--up); color: var(--bg); border-color: var(--up); font-weight: 700; }
    .chat-ind-group { display: flex; gap: 3px; }
    .chat-ind-chip { background: var(--bg); color: var(--dim); border: 1px solid var(--bdr); padding: 2px 8px; border-radius: 10px; font-family: var(--m); font-size: .72em; cursor: pointer; transition: .15s; }
    .chat-ind-chip.on { background: #5b8ff930; color: var(--acc); border-color: var(--acc); }
    .chat-toolbar .go { background: var(--up); color: var(--bg); font-weight: 700; font-size: .78em; padding: 4px 14px; border: none; border-radius: 5px; cursor: pointer; }
    .chat-toolbar .go:hover { opacity: .85; }
    .chat-mobile-tabs { display: none; padding: 6px 10px; gap: 4px; border-bottom: 1px solid var(--bdr); background: var(--bg2); }
    .chat-mtab { flex: 1; background: var(--bg); color: var(--dim); border: 1px solid var(--bdr); padding: 7px 0; border-radius: 6px; font-family: var(--f); font-size: .8em; font-weight: 600; cursor: pointer; text-align: center; transition: .18s; }
    .chat-mtab.active { background: var(--card); border-color: var(--acc); color: var(--acc); }
    @media (max-width: 800px) {
      .chat-mobile-tabs { display: flex; }
      .chat-main { flex-direction: column; height: calc(100vh - 280px); min-height: 400px; }
      .chat-chart-main { flex: 1; border-right: none; }
      .chat-sidebar { flex: 1; max-width: none; min-width: 0; }
      .chat-sidebar { display: none; }
      .chat-chart-main { display: flex; }
      .chat-main.show-conv .chat-chart-main { display: none; }
      .chat-main.show-conv .chat-sidebar { display: flex; }
    }
    @media(max-width:640px){.logo{font-size:2.2em}.tb{padding:7px 10px;font-size:.76em}.cw{height:340px!important}.feats{grid-template-columns:1fr 1fr}}
  </style>
</head>
<body>

<div class="hero">
  <div class="lang-sw">
    <button class="lb on" onclick="setLang('zh')">ä¸­æ–‡</button>
    <button class="lb" onclick="setLang('en')">EN</button>
  </div>
  <div class="logo">ğŸ¦ <span class="g">Gain</span>Lab</div>
  <div class="sub" data-i18n="subtitle">Agent çš„é‡‘èå›¾è¡¨ä¹‹çœ¼</div>
  <div class="tag" data-i18n="tagline">Agent ä¼šåˆ†æï¼Œä½†ä¸ä¼šç”»å›¾ã€‚GainLab å¸® Agent ç”»å›¾ã€‚</div>
  <div class="stats">
    <div class="s"><span class="d g"></span><span class="n">7</span><span class="l" data-i18n="stat_tools">å·¥å…·</span></div>
    <div class="s"><span class="d b"></span><span class="n">4</span><span class="l" data-i18n="stat_markets">å¸‚åœº</span></div>
    <div class="s"><span class="d y"></span><span class="n">275</span><span class="l" data-i18n="stat_tests">æµ‹è¯•</span></div>
  </div>
</div>

<div class="tnav">
  <button class="tb on" onclick="sw('kline',this)" data-i18n="tab_kline">ğŸ“Š Kçº¿</button>
  <button class="tb" onclick="sw('vp',this)" data-i18n="tab_vp">ğŸ“Š æˆäº¤é‡åˆ†å¸ƒ</button>
  <button class="tb" onclick="sw('indicators',this)" data-i18n="tab_indicators">ğŸ”§ æŠ€æœ¯æŒ‡æ ‡</button>
  <button class="tb" onclick="sw('overlay',this)" data-i18n="tab_overlay">ğŸ“ˆ å åŠ å¯¹æ¯”</button>
  <button class="tb" onclick="sw('fundamentals',this)" data-i18n="tab_fundamentals">ğŸ“‹ åŸºæœ¬é¢</button>
  <button class="tb" onclick="sw('wrb',this)" data-i18n="tab_wrb">ğŸ¯ WRBè¯„åˆ†</button>
  <button class="tb" onclick="sw('heatmap',this)" data-i18n="tab_heatmap">ğŸ”¥ çƒ­åŠ›å›¾</button>
  <button class="tb" onclick="sw('corr',this)" data-i18n="tab_corr">ğŸ”— ç›¸å…³æ€§</button>
  <button class="tb" onclick="sw('chat',this)" data-i18n="tab_chat">ğŸ¤– AI Chat</button>
</div>

<div class="demo">
  <div class="pnl on" id="p-kline">
    <div class="ctl">
      <select class="mkt mkt-sel" id="kl-m" onchange="umkt('kl')"></select>
      <select id="kl-s"></select>
      <select id="kl-t"><option value="1h">1H</option><option value="4h">4H</option><option value="1d" selected>1D</option><option value="1w">1W</option></select>
      <select id="kl-l"><option>60</option><option selected>100</option><option>200</option></select>
      <button class="go" onclick="lkl()" data-i18n="btn_load">åŠ è½½</button><div class="sp"></div><span class="st" id="kl-st">â€”</span>
    </div>
    <div class="cw" id="c-kline"></div>
  </div>

  <div class="pnl" id="p-vp">
    <div class="ctl">
      <select class="mkt mkt-sel" id="vp-m" onchange="umkt('vp')"></select>
      <select id="vp-s"></select>
      <select id="vp-t"><option value="1h">1H</option><option value="4h">4H</option><option value="1d" selected>1D</option></select>
      <select id="vp-l"><option>60</option><option selected>120</option><option>200</option></select>
      <select id="vp-r"><option value="12">12 rows</option><option value="24" selected>24 rows</option><option value="48">48 rows</option></select>
      <button class="go" onclick="lvp()" data-i18n="btn_load">åŠ è½½</button><div class="sp"></div><span class="st" id="vp-st">â€”</span>
    </div>
    <div class="cw" id="c-vp" style="height:520px"></div>
  </div>

  <div class="pnl" id="p-indicators">
    <div class="ctl">
      <select class="mkt mkt-sel" id="in-m" onchange="umkt('in')"></select>
      <select id="in-s"></select>
      <select id="in-i" multiple size="4" style="min-width:130px"><option value="MA" selected>MA</option><option value="VWAP">VWAP</option><option value="RSI" selected>RSI</option><option value="MACD">MACD</option><option value="BOLL">Bollinger</option><option value="ATR">ATR</option></select>
      <button class="go" onclick="lind()" data-i18n="btn_load">åŠ è½½</button><div class="sp"></div><span class="st" id="in-st">â€”</span>
    </div>
    <div class="cw" id="c-indicators" style="height:560px"></div>
  </div>

  <div class="pnl" id="p-overlay">
    <div class="ctl">
      <select id="ov-1"></select>
      <select id="ov-2"></select>
      <select id="ov-3"></select>
      <select id="ov-4"></select>
      <select id="ov-5"></select>
      <select id="ov-6"></select>
      <select id="ov-d"><option value="90">3M</option><option value="180" selected>6M</option><option value="365">1Y</option></select>
      <button class="go" onclick="lov()" data-i18n="btn_compare">å¯¹æ¯”</button><div class="sp"></div><span class="st" id="ov-st">â€”</span>
    </div>
    <div class="cw" id="c-overlay"></div>
  </div>

  <div class="pnl" id="p-fundamentals">
    <div class="ctl">
      <select id="fn-m"><option value="standard" selected>Standard</option><option value="dcf">DCF Gauge</option><option value="estimates">Analyst Estimates</option></select>
      <select id="fn-s" style="display:none"><option>AAPL</option><option>MSFT</option><option>GOOGL</option><option>TSLA</option><option>AMZN</option><option>NVDA</option></select>
      <button class="go" onclick="lfun()" data-i18n="btn_load">åŠ è½½</button><div class="sp"></div><span class="st" id="fn-st">Sample data â€” API keys required for live</span>
    </div>
    <div class="cw" id="c-fundamentals"></div>
  </div>

  <div class="pnl" id="p-wrb">
    <div class="ctl">
      <select class="mkt mkt-sel" id="wrb-m" onchange="umkt('wrb')"></select>
      <select id="wrb-s"></select>
      <select id="wrb-t"><option value="1h">1H</option><option value="4h">4H</option><option value="1d" selected>1D</option></select>
      <select id="wrb-l"><option>100</option><option selected>150</option><option>200</option></select>
      <button class="go" onclick="lwrb()" data-i18n="btn_analyze">åˆ†æ</button><div class="sp"></div><span class="st" id="wrb-st">â€”</span>
    </div>
    <div class="cw" id="c-wrb" style="height:540px"></div>
  </div>

  <div class="pnl" id="p-heatmap">
    <div class="ctl">
      <select id="hm-m"><option value="crypto" selected>Crypto</option></select>
      <select id="hm-l"><option value="30">Top 30</option><option value="50" selected>Top 50</option><option value="100">Top 100</option></select>
      <select id="hm-v"><option value="1000000" selected>Vol > $1M</option><option value="5000000">Vol > $5M</option><option value="10000000">Vol > $10M</option></select>
      <button class="go" onclick="lhm()" data-i18n="btn_load">åŠ è½½</button><div class="sp"></div><span class="st" id="hm-st">Live from Binance â€” no API key needed</span>
    </div>
    <div class="cw" id="c-heatmap" style="height:580px"></div>
  </div>

  <div class="pnl" id="p-corr">
    <div class="ctl">
      <select class="mkt" id="cr-m" onchange="umktCorr()"><option value="crypto">ğŸ”— Crypto</option><option value="cross">ğŸŒ Cross-Market</option></select>
      <select id="cr-a1"></select>
      <select id="cr-a2"></select>
      <select id="cr-a3"></select>
      <select id="cr-a4"></select>
      <select id="cr-d"><option value="60">60 days</option><option value="90" selected>90 days</option><option value="180">180 days</option></select>
      <button class="go" onclick="lcr()" data-i18n="btn_calculate">è®¡ç®—</button><div class="sp"></div><span class="st" id="cr-st">Pearson correlation from daily returns</span>
    </div>
    <div class="cw" id="c-corr" style="height:520px"></div>
  </div>

  <!-- AI Chat Panel -->
  <div class="pnl" id="p-chat">
    <!-- æ‰‹æœºç«¯ tab åˆ‡æ¢æŒ‰é’® -->
    <div class="chat-mobile-tabs" id="chat-mobile-tabs">
      <button class="chat-mtab active" onclick="chatMobileTab('chart')" id="chat-mtab-chart" data-i18n="chat_tab_chart">ğŸ“Š å›¾è¡¨</button>
      <button class="chat-mtab" onclick="chatMobileTab('conv')" id="chat-mtab-conv" data-i18n="chat_tab_conv">ğŸ’¬ å¯¹è¯</button>
    </div>
    <div class="chat-main">
      <!-- å·¦ä¾§/å›¾è¡¨åŒº -->
      <div class="chat-chart-main" id="chat-chart-main">
        <!-- Chart Toolbar -->
        <div class="chat-toolbar" id="chat-toolbar">
          <select id="ct-market" class="mkt-sel" onchange="chatToolbarUpdateSymbols()">
            <option value="crypto">ğŸ”— Crypto</option>
            <option value="us_stock">ğŸ‡ºğŸ‡¸ US Stock</option>
            <option value="a_stock">ğŸ‡¨ğŸ‡³ A-Share</option>
            <option value="commodity">ğŸ¥‡ Gold/Silver</option>
            <option value="index">ğŸ“Š Index</option>
          </select>
          <select id="ct-symbol"></select>
          <div class="chat-tf-group">
            <button class="chat-tf-btn" data-tf="1h" onclick="chatTfSelect(this)">1H</button>
            <button class="chat-tf-btn" data-tf="4h" onclick="chatTfSelect(this)">4H</button>
            <button class="chat-tf-btn on" data-tf="1d" onclick="chatTfSelect(this)">1D</button>
            <button class="chat-tf-btn" data-tf="1w" onclick="chatTfSelect(this)">1W</button>
          </div>
          <div class="chat-ind-group">
            <button class="chat-ind-chip" data-ind="MA" onclick="chatIndToggle(this)">MA</button>
            <button class="chat-ind-chip" data-ind="RSI" onclick="chatIndToggle(this)">RSI</button>
            <button class="chat-ind-chip" data-ind="MACD" onclick="chatIndToggle(this)">MACD</button>
            <button class="chat-ind-chip" data-ind="BOLL" onclick="chatIndToggle(this)">BOLL</button>
            <button class="chat-ind-chip" data-ind="VOL" onclick="chatIndToggle(this)">VOL</button>
          </div>
          <button class="go" onclick="chatToolbarGo()" data-i18n="chat_tb_go">ç”Ÿæˆ</button>
        </div>
        <div class="chat-chart-wrap" id="chat-chart-wrap">
          <!-- å ä½ç¬¦ï¼ˆæœªç”Ÿæˆå›¾è¡¨æ—¶æ˜¾ç¤ºï¼‰ -->
          <div class="chat-chart-empty" id="chat-chart-empty">
            <div style="font-size:3em;margin-bottom:12px;opacity:.5">ğŸ“Š</div>
            <div style="color:var(--dim);font-size:.9em" data-i18n="chat_chart_hint">é€‰æ‹©é¢„è®¾é—®é¢˜æˆ–è¾“å…¥æ¥ç”Ÿæˆå›¾è¡¨</div>
          </div>
          <!-- å›¾è¡¨å®¹å™¨ -->
          <div id="c-chat-main" style="position:absolute;inset:0;display:none"></div>
        </div>
        <!-- å›¾è¡¨ä¸‹æ–¹çŠ¶æ€æ  -->
        <div class="chat-chart-status" id="chat-chart-status"></div>
      </div>
      <!-- å³ä¾§/å¯¹è¯åŒº -->
      <div class="chat-sidebar" id="chat-sidebar">
        <div class="chat-sidebar-header">
          <span style="font-weight:700;color:var(--acc)">ğŸ¤– GainLab AI</span>
        </div>
        <div class="chat-messages" id="chat-messages"></div>
        <div class="chat-presets" id="chat-presets">
          <button class="chat-preset-btn" onclick="sendChatMessage('Show BTC daily K-line')" data-i18n="chat_p_kline">ğŸ“Š BTC K-line</button>
          <button class="chat-preset-btn" onclick="sendChatMessage('Compare BTC, ETH and Gold')" data-i18n="chat_p_overlay">ğŸ“ˆ BTC vs ETH vs Gold</button>
          <button class="chat-preset-btn" onclick="sendChatMessage('BTC with RSI, MACD, Bollinger Bands')" data-i18n="chat_p_indicators">ğŸ”§ BTC Indicators</button>
          <button class="chat-preset-btn" onclick="sendChatMessage('Show Apple fundamentals analysis')" data-i18n="chat_p_fundamentals">ğŸ“‹ Apple Fundamentals</button>
          <button class="chat-preset-btn" onclick="sendChatMessage('Show BTC volume profile')" data-i18n="chat_p_vp">ğŸ“Š BTC Volume Profile</button>
          <button class="chat-preset-btn" onclick="sendChatMessage('Show crypto sector heatmap')" data-i18n="chat_p_heatmap">ğŸ”¥ Crypto Heatmap</button>
          <button class="chat-preset-btn" onclick="sendChatMessage('Analyze BTC for WRB patterns')" data-i18n="chat_p_wrb">ğŸ¯ BTC WRB Analysis</button>
        </div>
        <div class="chat-input-row">
          <input class="chat-input" id="chat-input" type="text" data-i18n-placeholder="chat_placeholder" placeholder="è¾“å…¥é‡‘èåˆ†æé—®é¢˜..." onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();chatSend()}">
          <button class="chat-send-btn" id="chat-send-btn" onclick="chatSend()" data-i18n="chat_send">å‘é€</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="code-s">
  <h3 data-i18n="code_title">æ”¯æŒä»»æ„ MCP å®¢æˆ·ç«¯</h3>
  <div class="cb"><span class="c">// Ask your AI agent:</span>
"Draw a BTC daily chart with RSI and MACD"
"Analyze AAPL with WRB/HG scoring"
"Show me a DCF valuation for MSFT"

<span class="c">// Or call MCP tools directly:</span>
{
  <span class="s">"tool"</span>: <span class="s">"gainlab_indicators"</span>,
  <span class="s">"symbol"</span>: <span class="s">"BTCUSDT"</span>,
  <span class="s">"market"</span>: <span class="s">"crypto"</span>,
  <span class="s">"indicators"</span>: [<span class="s">"MA"</span>, <span class="s">"RSI"</span>, <span class="s">"MACD"</span>]
}
{
  <span class="s">"tool"</span>: <span class="s">"gainlab_wrb_scoring"</span>,
  <span class="s">"symbol"</span>: <span class="s">"BTCUSDT"</span>,
  <span class="s">"market"</span>: <span class="s">"crypto"</span>,
  <span class="s">"sensitivity"</span>: <span class="n">1.5</span>
}</div>
</div>

<div class="feats">
  <div class="ft"><div class="i">ğŸ“Š</div><h4>K-Line Charts</h4><p>Professional candlestick + volume. Crypto, US stocks, A-shares, commodities.</p><span class="tg lv">âœ… live</span></div>
  <div class="ft"><div class="i">ğŸ”§</div><h4>Technical Indicators</h4><p>MA, EMA, RSI, MACD, Bollinger, KDJ. Dynamic multi-panel layout.</p><span class="tg lv">âœ… live</span></div>
  <div class="ft"><div class="i">ğŸ“ˆ</div><h4>Multi-Asset Overlay</h4><p>Compare 2-6 assets. Normalized % change. Cross-market.</p><span class="tg lv">âœ… live</span></div>
  <div class="ft"><div class="i">ğŸ“‹</div><h4>Fundamentals</h4><p>Revenue, margins, EPS. DCF valuation gauge. Analyst estimates. Peer comparison.</p><span class="tg lv">âœ… live</span></div>
  <div class="ft"><div class="i">ğŸ¯</div><h4>WRB/HG Scoring</h4><p>Wide Range Bar + Hidden Gap detection. ABC scoring with Pro signals for entries.</p><span class="tg lv">âœ… live</span></div>
  <div class="ft"><div class="i">ğŸ“Š</div><h4>Volume Profile</h4><p>POC, Value Area, price-volume distribution. Interactive VP chart.</p><span class="tg lv">âœ… live</span></div>
  <div class="ft"><div class="i">ğŸ“‰</div><h4>VWAP + ATR</h4><p>Institutional VWAP, Anchored VWAP, and ATR volatility.</p><span class="tg lv">âœ… live</span></div>
  <div class="ft"><div class="i">ğŸ”¥</div><h4>Sector Heatmap</h4><p>Finviz-style treemap. Block size = volume, color = 24h change.</p><span class="tg lv">âœ… live</span></div>
  <div class="ft"><div class="i">ğŸ”—</div><h4>Correlation Matrix</h4><p>NÃ—N Pearson correlation. Cross-market asset comparison.</p><span class="tg lv">âœ… live</span></div>
  <div class="ft"><div class="i">ğŸ“…</div><h4>Financial Calendar</h4><p>Earnings, FOMC, CPI, token unlocks.</p><span class="tg sn">phase 3</span></div>
  <div class="ft"><div class="i">âš¡</div><h4>Funding Rate</h4><p>Crypto perpetual rates across exchanges.</p><span class="tg sn">phase 3</span></div>
  <div class="ft"><div class="i">ğŸ””</div><h4>Smart Alerts</h4><p>Price, event & indicator alerts.</p><span class="tg sn">phase 4</span></div>
</div>

<div class="arch-s">
  <h3 data-i18n="arch_title">æ¶æ„</h3>
  <div class="arch">Agent (Claude / ChatGPT / OpenClaw / custom)
  â”‚ MCP Protocol
  â–¼
@gainlab/mcp-server
  â”œâ”€â”€ tools/    â†’ 7 MCP tools (kline, volume-profile, indicators, overlay, fundamentals, heatmap, wrb-scoring)
  â”œâ”€â”€ data/     â†’ 4 markets (Binance Â· FMP Â· EODHD)
  â”œâ”€â”€ render/   â†’ ECharts (interactive HTML + server-side PNG)
  â””â”€â”€ utils/    â†’ TA math (zero deps) + proxy-aware fetch</div>
</div>

<div class="ftr">
  <div class="lk"><a href="https://github.com/Ashersun1207/gainlab-mcp">GitHub</a><a href="https://github.com/Ashersun1207/gainlab-mcp#quick-start">Docs</a><a href="https://github.com/Ashersun1207/gainlab-mcp/blob/main/LICENSE">Apache 2.0</a></div>
  <span data-i18n="footer">ç”± Asher å’Œ æ™ºæ…§å·å· ğŸ¦ æ„å»º</span>
</div>

<script>
const U='#00d4aa',D='#ff4757',B='#0d0d1f',G='#1a1a35',T='#e8e8f0',S='#8888aa',P=['#00d4aa','#5b8ff9','#ff4757','#ffc233','#7c4dff'];
const ch={};
function ic(id){if(!ch[id]){ch[id]=echarts.init(document.getElementById(id));window.addEventListener('resize',()=>ch[id]?.resize())}return ch[id]}

// I18N system
const I18N = {
  zh: {
    subtitle: 'Agent çš„é‡‘èå›¾è¡¨ä¹‹çœ¼',
    tagline: 'Agent ä¼šåˆ†æï¼Œä½†ä¸ä¼šç”»å›¾ã€‚GainLab å¸® Agent ç”»å›¾ã€‚',
    stat_tools: 'å·¥å…·',
    stat_markets: 'å¸‚åœº',
    stat_tests: 'æµ‹è¯•',
    tab_kline: 'ğŸ“Š Kçº¿',
    tab_vp: 'ğŸ“Š æˆäº¤é‡åˆ†å¸ƒ',
    tab_indicators: 'ğŸ”§ æŠ€æœ¯æŒ‡æ ‡',
    tab_overlay: 'ğŸ“ˆ å åŠ å¯¹æ¯”',
    tab_fundamentals: 'ğŸ“‹ åŸºæœ¬é¢',
    tab_wrb: 'ğŸ¯ WRBè¯„åˆ†',
    tab_heatmap: 'ğŸ”¥ çƒ­åŠ›å›¾',
    tab_corr: 'ğŸ”— ç›¸å…³æ€§',
    tab_chat: 'ğŸ¤– AI å¯¹è¯',
    chat_placeholder: 'è¾“å…¥é‡‘èåˆ†æé—®é¢˜...',
    chat_send: 'å‘é€',
    chat_thinking: 'æ€è€ƒä¸­...',
    chat_welcome: 'ä½ å¥½ï¼æˆ‘æ˜¯ GainLab Demo Agentï¼Œå¯ä»¥ç”¨è‡ªç„¶è¯­è¨€å¸®ä½ ç”Ÿæˆé‡‘èå›¾è¡¨ã€‚ç‚¹å‡»ä¸‹æ–¹é¢„è®¾é—®é¢˜ï¼Œæˆ–è€…è¾“å…¥è‡ªå®šä¹‰é—®é¢˜è¯•è¯•çœ‹ï¼',
    chat_chart_hint: 'é€‰æ‹©é¢„è®¾é—®é¢˜æˆ–è¾“å…¥æ¥ç”Ÿæˆå›¾è¡¨',
    chat_tab_chart: 'ğŸ“Š å›¾è¡¨',
    chat_tab_conv: 'ğŸ’¬ å¯¹è¯',
    chat_p_kline: 'ğŸ“Š BTC Kçº¿',
    chat_p_overlay: 'ğŸ“ˆ BTC vs ETH vs é»„é‡‘',
    chat_p_indicators: 'ğŸ”§ BTC æŠ€æœ¯æŒ‡æ ‡',
    chat_p_fundamentals: 'ğŸ“‹ è‹¹æœåŸºæœ¬é¢',
    chat_p_vp: 'ğŸ“Š BTC æˆäº¤é‡åˆ†å¸ƒ',
    chat_p_heatmap: 'ğŸ”¥ åŠ å¯†çƒ­åŠ›å›¾',
    chat_p_wrb: 'ğŸ¯ BTC WRB åˆ†æ',
    chat_tb_go: 'ç”Ÿæˆ',
    mkt_crypto: 'ğŸ”— åŠ å¯†è´§å¸',
    mkt_us_stock: 'ğŸ‡ºğŸ‡¸ ç¾è‚¡',
    mkt_a_stock: 'ğŸ‡¨ğŸ‡³ Aè‚¡',
    mkt_commodity: 'ğŸ¥‡ è´µé‡‘å±',
    mkt_index: 'ğŸ“Š æŒ‡æ•°',
    btn_load: 'åŠ è½½',
    btn_analyze: 'åˆ†æ',
    btn_compare: 'å¯¹æ¯”',
    btn_calculate: 'è®¡ç®—',
    wrb_bull: 'çœ‹æ¶¨',
    wrb_bear: 'çœ‹è·Œ',
    code_title: 'æ”¯æŒä»»æ„ MCP å®¢æˆ·ç«¯',
    arch_title: 'æ¶æ„',
    footer: 'ç”± Asher å’Œ æ™ºæ…§å·å· ğŸ¦ æ„å»º'
  },
  en: {
    subtitle: "Agent's Eyes for Financial Charts",
    tagline: "Agents can analyze, but they can't draw charts. GainLab gives agents eyes.",
    stat_tools: 'tools',
    stat_markets: 'markets',
    stat_tests: 'tests',
    tab_kline: 'ğŸ“Š K-Line',
    tab_vp: 'ğŸ“Š Volume Profile',
    tab_indicators: 'ğŸ”§ Indicators',
    tab_overlay: 'ğŸ“ˆ Overlay',
    tab_fundamentals: 'ğŸ“‹ Fundamentals',
    tab_wrb: 'ğŸ¯ WRB Scoring',
    tab_heatmap: 'ğŸ”¥ Heatmap',
    tab_corr: 'ğŸ”— Correlation',
    tab_chat: 'ğŸ¤– AI Chat',
    chat_placeholder: 'Ask a financial analysis question...',
    chat_send: 'Send',
    chat_thinking: 'Thinking...',
    chat_welcome: 'Hello! I am GainLab Demo Agent. I can generate financial charts using natural language. Click a preset question below, or type your own!',
    chat_chart_hint: 'Select a preset or type to generate a chart',
    chat_tab_chart: 'ğŸ“Š Chart',
    chat_tab_conv: 'ğŸ’¬ Chat',
    chat_p_kline: 'ğŸ“Š BTC K-line',
    chat_p_overlay: 'ğŸ“ˆ BTC vs ETH vs Gold',
    chat_p_indicators: 'ğŸ”§ BTC Indicators',
    chat_p_fundamentals: 'ğŸ“‹ Apple Fundamentals',
    chat_p_vp: 'ğŸ“Š BTC Volume Profile',
    chat_p_heatmap: 'ğŸ”¥ Crypto Heatmap',
    chat_p_wrb: 'ğŸ¯ BTC WRB Analysis',
    chat_tb_go: 'Go',
    mkt_crypto: 'ğŸ”— Crypto',
    mkt_us_stock: 'ğŸ‡ºğŸ‡¸ US Stock',
    mkt_a_stock: 'ğŸ‡¨ğŸ‡³ A-Share',
    mkt_commodity: 'ğŸ¥‡ Gold/Silver',
    mkt_index: 'ğŸ“Š Index',
    btn_load: 'Load',
    btn_analyze: 'Analyze',
    btn_compare: 'Compare',
    btn_calculate: 'Calculate',
    wrb_bull: 'Bull',
    wrb_bear: 'Bear',
    code_title: 'Use with any MCP Client',
    arch_title: 'Architecture',
    footer: 'Built by Asher & æ™ºæ…§å·å· ğŸ¦'
  }
};
let curLang = 'zh';
function t(key) { return I18N[curLang]?.[key] || I18N.en[key] || key; }
function setLang(lang) {
  curLang = lang;
  // Update button states
  document.querySelectorAll('.lb').forEach(btn => {
    btn.classList.toggle('on', btn.textContent.includes(lang === 'zh' ? 'ä¸­æ–‡' : 'EN'));
  });
  // Update all data-i18n elements
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.getAttribute('data-i18n');
    el.textContent = t(key);
  });
  // Update market selectors
  updateMarketSelectors();
}
function updateMarketSelectors() {
  document.querySelectorAll('.mkt-sel').forEach(sel => {
    const curVal = sel.value || 'crypto';
    sel.innerHTML = `
      <option value="crypto">${t('mkt_crypto')}</option>
      <option value="us_stock">${t('mkt_us_stock')}</option>
      <option value="a_stock">${t('mkt_a_stock')}</option>
      <option value="commodity">${t('mkt_commodity')}</option>
      ${sel.id !== 'wrb-m' ? `<option value="index">${t('mkt_index')}</option>` : ''}
    `;
    sel.value = curVal;
  });
}

// Market â†’ symbol mapping
const MKT_SYMS={
crypto:[{v:'BTCUSDT',l:'BTC/USDT'},{v:'ETHUSDT',l:'ETH/USDT'},{v:'SOLUSDT',l:'SOL/USDT'},{v:'BNBUSDT',l:'BNB/USDT'}],
us_stock:[{v:'AAPL',l:'AAPL'},{v:'MSFT',l:'MSFT'},{v:'NVDA',l:'NVDA'},{v:'TSLA',l:'TSLA'}],
a_stock:[{v:'600519',l:'è´µå·èŒ…å°'},{v:'000001',l:'å¹³å®‰é“¶è¡Œ'}],
commodity:[{v:'XAUUSD',l:'Gold (XAU)'},{v:'XAGUSD',l:'Silver (XAG)'}],
index:[{v:'SPY',l:'S&P 500'},{v:'QQQ',l:'NASDAQ'}]
};

// Update symbol select when market changes
function umkt(prefix){
const m=$(prefix+'-m').value;
const syms=MKT_SYMS[m]||MKT_SYMS.crypto;
const sel=$(prefix+'-s');
sel.innerHTML=syms.map(s=>`<option value="${s.v}">${s.l}</option>`).join('');
}

// Correlation cross-market mode
function umktCorr(){
const m=$('cr-m').value;
const sels=['cr-a1','cr-a2','cr-a3','cr-a4'];
if(m==='cross'){
  const cross=[{v:'AAPL',l:'AAPL'},{v:'NVDA',l:'NVDA'},{v:'XAUUSD',l:'Gold'},{v:'SPY',l:'S&P 500'},{v:'600519',l:'è´µå·èŒ…å°'},{v:'QQQ',l:'NASDAQ'}];
  sels.forEach((id,i)=>{const s=$(id);s.innerHTML=(i===3?'<option value="">â€” none â€”</option>':'')+cross.map((c,j)=>`<option value="${c.v}"${j===i?' selected':''}>${c.l}</option>`).join('')})
}else{
  const crSyms=[...MKT_SYMS.crypto,{v:'DOGEUSDT',l:'DOGE/USDT'},{v:'XRPUSDT',l:'XRP/USDT'},{v:'ADAUSDT',l:'ADA/USDT'},{v:'AVAXUSDT',l:'AVAX/USDT'}];
  const defs=['BTCUSDT','ETHUSDT','SOLUSDT',''];
  sels.forEach((id,i)=>{const s=$(id);s.innerHTML=(i===3?'<option value="">â€” none â€”</option>':'')+crSyms.map(c=>`<option value="${c.v}"${c.v===defs[i]?' selected':''}>${c.l}</option>`).join('')})
}}

// Fetch data: crypto=live Binance, others=sample SD
async function fdata(sym,tf,lim){
// Check if it's a crypto pair (ends with USDT)
if(sym.endsWith('USDT'))return fb(sym,tf,lim);
// Otherwise use sample data
if(typeof SD!=='undefined'&&SD[sym]){
  const d=SD[sym].slice(-lim);
  // Format same as Binance: [ts, open, high, low, close, volume]
  return d.map(k=>[k[0],String(k[1]),String(k[2]),String(k[3]),String(k[4]),String(k[5])])
}
throw new Error('No data for '+sym+' â€” sample data not loaded')
}
function sw(n,el){document.querySelectorAll('.tb').forEach(b=>b.classList.remove('on'));document.querySelectorAll('.pnl').forEach(p=>p.classList.remove('on'));el.classList.add('on');document.getElementById('p-'+n).classList.add('on');if(n==='kline'&&!ch['c-kline'])lkl();if(n==='vp'&&!ch['c-vp'])lvp();if(n==='indicators'&&!ch['c-indicators'])lind();if(n==='overlay'&&!ch['c-overlay'])lov();if(n==='fundamentals'&&!ch['c-fundamentals'])lfun();if(n==='wrb'&&!ch['c-wrb'])lwrb();if(n==='heatmap'&&!ch['c-heatmap'])lhm();if(n==='corr'&&!ch['c-corr'])lcr();setTimeout(()=>{if(ch['c-'+n])ch['c-'+n].resize()},50)}
async function fb(s,i,l){return(await fetch(`https://api.binance.com/api/v3/klines?symbol=${s}&interval=${i}&limit=${l}`)).json()}
function fd(ts,tf){const d=new Date(ts);return(tf.includes('m')||tf==='1h'||tf==='4h')?d.toLocaleString('en-US',{month:'short',day:'numeric',hour:'2-digit',minute:'2-digit'}):d.toLocaleDateString('en-US',{year:'numeric',month:'short',day:'numeric'})}

// VOLUME PROFILE
function calcVP(klines,rows=24,vaP=0.7){
let gH=-Infinity,gL=Infinity;klines.forEach(k=>{gH=Math.max(gH,+k[2]);gL=Math.min(gL,+k[3])});
if(gH===gL){const tv=klines.reduce((a,k)=>a+(+k[5]),0);return{rows:[{pMin:gL,pMax:gH,pMid:gL,vol:tv,bv:0,sv:0}],poc:gL,vah:gH,val:gL}}
const rH=(gH-gL)/rows,vr=[];for(let i=0;i<rows;i++){vr.push({pMin:gL+i*rH,pMax:gL+(i+1)*rH,pMid:gL+(i+.5)*rH,vol:0,bv:0,sv:0})}
let tv=0;klines.forEach(k=>{const h=+k[2],l=+k[3],c=+k[4],o=+k[1],v=+k[5],buy=c>o;tv+=v;
if(h===l){const ri=Math.min(Math.max(0,Math.floor((c-gL)/rH)),rows-1);if(buy)vr[ri].bv+=v;else vr[ri].sv+=v;vr[ri].vol+=v}
else{const sr=Math.max(0,Math.floor((l-gL)/rH)),er=Math.min(rows-1,Math.floor((h-gL)/rH));
for(let r=sr;r<=er;r++){const ol=Math.max(l,vr[r].pMin),oh=Math.min(h,vr[r].pMax),p=Math.max(0,oh-ol)/(h-l),vl=v*p;
if(buy)vr[r].bv+=vl;else vr[r].sv+=vl;vr[r].vol+=vl}}});
let pi=0,mx=0;vr.forEach((r,i)=>{if(r.vol>mx){mx=r.vol;pi=i}});
let cv=vr[pi].vol,lo=pi,hi=pi;const tgt=tv*vaP;
while(cv<tgt&&(lo>0||hi<rows-1)){const bv=lo>0?vr[lo-1].vol:-1,av=hi<rows-1?vr[hi+1].vol:-1;
if(bv>=av&&bv>=0){lo--;cv+=vr[lo].vol}else if(av>=0){hi++;cv+=vr[hi].vol}else break}
return{rows:vr,poc:vr[pi].pMid,vah:vr[hi].pMax,val:vr[lo].pMin,pocIdx:pi,vaLo:lo,vaHi:hi}}

async function lvp(){const s=$('vp-s').value,tf=$('vp-t').value,l=+$('vp-l').value,rows=+$('vp-r').value,m=$('vp-m')?.value||'crypto';$('vp-st').textContent='Loading...';
try{const r=await fdata(s,tf,l),dt=r.map(k=>fd(k[0],tf)),oh=r.map(k=>[+k[1],+k[4],+k[3],+k[2]]),v=r.map(k=>+k[5]),vc=r.map(k=>+k[4]>=+k[1]?U+'80':D+'80');
const vp=calcVP(r,rows);const maxV=Math.max(...vp.rows.map(r=>r.vol));
const dispName=s.endsWith('USDT')?s:MKT_SYMS[m]?.find(x=>x.v===s)?.l||s;
// Calculate price range
const vpPriceMin=vp.rows[0].pMin,vpPriceMax=vp.rows[vp.rows.length-1].pMax;
const priceMargin=(vpPriceMax-vpPriceMin)*0.02;
// Build horizontal VP bars (index is row, value is volume at that price level)
const vpBars=vp.rows.map((row,i)=>({
  name:row.pMid.toFixed(2),
  value:[row.vol,row.pMid],
  buy:row.bv,
  sell:row.sv,
  isPOC:i===vp.pocIdx
}));
const rowH=(vpPriceMax-vpPriceMin)/rows; // height of each VP bar in price units
const ch2=ic('c-vp');
ch2.setOption({backgroundColor:B,animation:false,title:{text:`${dispName} â€” ${tf} VP`,left:'center',textStyle:{color:T,fontSize:15,fontWeight:700}},
tooltip:{trigger:'axis',axisPointer:{type:'cross'},backgroundColor:'#1e1e3d',borderColor:'#2a2a4a',textStyle:{color:T}},
grid:[
{left:'6%',right:'28%',top:'8%',height:'60%'},
{left:'6%',right:'28%',top:'72%',height:'12%'},
{left:'74%',right:'2%',top:'8%',height:'60%'}
],
xAxis:[
{type:'category',data:dt,gridIndex:0,axisLine:{lineStyle:{color:G}},axisLabel:{color:S,fontSize:9},splitLine:{show:false}},
{type:'category',data:dt,gridIndex:1,axisLine:{lineStyle:{color:G}},axisLabel:{show:false},splitLine:{show:false}},
{type:'value',gridIndex:2,axisLine:{lineStyle:{color:G}},axisLabel:{show:false},splitLine:{show:false},max:maxV*1.1}
],
yAxis:[
{type:'value',gridIndex:0,splitLine:{lineStyle:{color:G}},axisLabel:{color:S},min:vpPriceMin-priceMargin,max:vpPriceMax+priceMargin},
{type:'value',gridIndex:1,splitLine:{show:false},axisLabel:{show:false},axisLine:{show:false}},
{type:'value',gridIndex:2,axisLine:{lineStyle:{color:G}},axisLabel:{color:S,fontSize:7,formatter:v=>v.toFixed(0)},splitLine:{lineStyle:{color:G,opacity:0.3}},min:vpPriceMin-priceMargin,max:vpPriceMax+priceMargin}
],
series:[
{type:'candlestick',data:oh,xAxisIndex:0,yAxisIndex:0,itemStyle:{color:U,color0:D,borderColor:U,borderColor0:D},
markLine:{silent:true,symbol:'none',lineStyle:{width:2},data:[
{yAxis:vp.poc,lineStyle:{color:'#ff4757',type:'solid'},label:{formatter:'POC '+vp.poc.toFixed(2),color:'#ff4757',fontSize:11,fontWeight:'bold',position:'end'}},
{yAxis:vp.vah,lineStyle:{color:'#ffc233',type:'dashed'},label:{formatter:'VAH '+vp.vah.toFixed(2),color:'#ffc233',fontSize:10,position:'end'}},
{yAxis:vp.val,lineStyle:{color:'#ffc233',type:'dashed'},label:{formatter:'VAL '+vp.val.toFixed(2),color:'#ffc233',fontSize:10,position:'end'}}
]},
markArea:{silent:true,data:[[{yAxis:vp.val,itemStyle:{color:'#ffc23315'}},{yAxis:vp.vah}]]}
},
{type:'bar',data:v.map((x,i)=>({value:x,itemStyle:{color:vc[i]}})),xAxisIndex:1,yAxisIndex:1},
{name:'VP',type:'custom',xAxisIndex:2,yAxisIndex:2,renderItem:function(params,api){
const idx=params.dataIndex;const row=vp.rows[idx];if(!row)return;
const buyV=row.bv,sellV=row.sv;
const yBottom=api.coord([0,row.pMin])[1];const yTop=api.coord([0,row.pMax])[1];
const xBuyEnd=api.coord([buyV,0])[0];const xSellEnd=api.coord([buyV+sellV,0])[0];
const xOrigin=api.coord([0,0])[0];
const isPOC=idx===vp.pocIdx;
const group={type:'group',children:[]};
// Buy volume bar
if(buyV>0)group.children.push({type:'rect',shape:{x:xOrigin,y:yTop,width:xBuyEnd-xOrigin,height:yBottom-yTop},style:{fill:isPOC?'#fff':U,stroke:isPOC?'#fff':'transparent',lineWidth:isPOC?2:0}});
// Sell volume bar
if(sellV>0)group.children.push({type:'rect',shape:{x:xBuyEnd,y:yTop,width:xSellEnd-xBuyEnd,height:yBottom-yTop},style:{fill:isPOC?'#ccc':D,stroke:isPOC?'#fff':'transparent',lineWidth:isPOC?2:0}});
return group},
data:vp.rows.map((row,i)=>[row.bv+row.sv,row.pMid]),
tooltip:{formatter:function(p){const row=vp.rows[p.dataIndex];if(!row)return'';return`Price: ${row.pMid.toFixed(2)}<br>Buy: ${row.bv.toFixed(0)}<br>Sell: ${row.sv.toFixed(0)}<br>Total: ${row.vol.toFixed(0)}${p.dataIndex===vp.pocIdx?' (POC)':''}`}}
}
],
dataZoom:[{type:'inside',xAxisIndex:[0,1]}]
},true);
$('vp-st').textContent=`POC: ${vp.poc.toFixed(2)} | VAH: ${vp.vah.toFixed(2)} | VAL: ${vp.val.toFixed(2)} Â· ${r.length} candles`
}catch(e){$('vp-st').textContent='Error: '+e.message}}

// VWAP helper
function vwap(klines){const r=[];let ctpv=0,cv=0;klines.forEach(k=>{const tp=(+k[2]+ +k[3]+ +k[4])/3;ctpv+=tp*(+k[5]);cv+= +k[5];r.push(cv===0?null:ctpv/cv)});return r}
// ATR helper
function atr(klines,p=14){const tr=[];klines.forEach((k,i)=>{if(!i){tr.push(+k[2]- +k[3])}else{const hl=+k[2]- +k[3],hpc=Math.abs(+k[2]- +klines[i-1][4]),lpc=Math.abs(+k[3]- +klines[i-1][4]);tr.push(Math.max(hl,hpc,lpc))}});
const r=[];let a=0;for(let i=0;i<tr.length;i++){if(i<p-1){r.push(null)}else if(i===p-1){a=tr.slice(0,p).reduce((s,v)=>s+v,0)/p;r.push(a)}else{a=(a*(p-1)+tr[i])/p;r.push(a)}}return r}

// K-LINE
async function lkl(){const s=$('kl-s').value,tf=$('kl-t').value,l=+$('kl-l').value,m=$('kl-m')?.value||'crypto';$('kl-st').textContent='Loading...';
try{const r=await fdata(s,tf,l),dt=r.map(k=>fd(k[0],tf)),oh=r.map(k=>[+k[1],+k[4],+k[3],+k[2]]),v=r.map(k=>+k[5]),vc=r.map(k=>+k[4]>=+k[1]?U+'80':D+'80');const isSample=!s.endsWith('USDT');
const dispName=s.endsWith('USDT')?s:MKT_SYMS[m]?.find(x=>x.v===s)?.l||s;
ic('c-kline').setOption({backgroundColor:B,animation:false,title:{text:`${dispName} â€” ${tf}`,left:'center',textStyle:{color:T,fontSize:15,fontWeight:700}},tooltip:{trigger:'axis',axisPointer:{type:'cross'},backgroundColor:'#1e1e3d',borderColor:'#2a2a4a',textStyle:{color:T}},grid:[{left:'8%',right:'4%',top:'10%',height:'56%'},{left:'8%',right:'4%',top:'70%',height:'18%'}],xAxis:[{type:'category',data:dt,gridIndex:0,axisLine:{lineStyle:{color:G}},axisLabel:{color:S,fontSize:10},splitLine:{show:false}},{type:'category',data:dt,gridIndex:1,axisLine:{lineStyle:{color:G}},axisLabel:{show:false},splitLine:{show:false}}],yAxis:[{type:'value',gridIndex:0,splitLine:{lineStyle:{color:G}},axisLabel:{color:S},scale:true},{type:'value',gridIndex:1,splitLine:{show:false},axisLabel:{show:false},axisLine:{show:false}}],series:[{type:'candlestick',data:oh,itemStyle:{color:U,color0:D,borderColor:U,borderColor0:D}},{type:'bar',data:v.map((x,i)=>({value:x,itemStyle:{color:vc[i]}})),xAxisIndex:1,yAxisIndex:1}],dataZoom:[{type:'inside',xAxisIndex:[0,1]}]},true);
const la=r[r.length-1],pc=((+la[4]-+la[1])/+la[1]*100).toFixed(2);$('kl-st').textContent=`Last: ${(+la[4]).toLocaleString()} (${pc>=0?'+':''}${pc}%) Â· ${r.length} candles${isSample?' (sample)':''}`}catch(e){$('kl-st').textContent='Error: '+e.message}}

// TA helpers
function ma(c,p){return c.map((_,i)=>i<p-1?null:c.slice(i-p+1,i+1).reduce((a,b)=>a+b,0)/p)}
function ema(d,p){const r=[],m=2/(p+1);d.forEach((v,i)=>{i===0?r.push(v):r.push(v*m+r[i-1]*(1-m))});return r}
function rsi(c,p=14){const r=[];let ag=0,al=0;for(let i=0;i<c.length;i++){if(!i){r.push(null);continue}const d=c[i]-c[i-1],g=d>0?d:0,l=d<0?-d:0;if(i<=p){ag+=g/p;al+=l/p;r.push(i<p?null:100-100/(1+ag/(al||.001)))}else{ag=(ag*(p-1)+g)/p;al=(al*(p-1)+l)/p;r.push(100-100/(1+ag/(al||.001)))}}return r}
function macd(c){const e12=ema(c,12),e26=ema(c,26),m=e12.map((v,i)=>v-e26[i]),s=ema(m,9),h=m.map((v,i)=>v-s[i]);return{m,s,h}}
function boll(c,p=20){const mid=ma(c,p),up=[],lo=[];for(let i=0;i<c.length;i++){if(mid[i]===null){up.push(null);lo.push(null);continue}const sl=c.slice(i-p+1,i+1),sd=Math.sqrt(sl.reduce((a,v)=>a+(v-mid[i])**2,0)/p);up.push(mid[i]+2*sd);lo.push(mid[i]-2*sd)}return{mid,up,lo}}

// INDICATORS
async function lind(){const s=$('in-s').value,sel=Array.from($('in-i').selectedOptions).map(o=>o.value);$('in-st').textContent='Loading...';
try{const r=await fdata(s,'1d',120),dt=r.map(k=>fd(k[0],'1d')),cl=r.map(k=>+k[4]),oh=r.map(k=>[+k[1],+k[4],+k[3],+k[2]]),v=r.map(k=>+k[5]),vc=r.map(k=>+k[4]>=+k[1]?U+'80':D+'80');
const hasRSI=sel.includes('RSI'),hasMACD=sel.includes('MACD'),hasATR=sel.includes('ATR');let subN=0;if(hasRSI)subN++;if(hasMACD)subN++;if(hasATR)subN++;
const mainH=subN===0?52:subN===1?40:subN===2?34:28,volT=10+mainH+2,volH=8;
const grids=[{left:'8%',right:'4%',top:'8%',height:mainH+'%'},{left:'8%',right:'4%',top:(10+mainH)+'%',height:volH+'%'}];
const xA=[{type:'category',data:dt,gridIndex:0,axisLine:{lineStyle:{color:G}},axisLabel:{color:S,fontSize:9},splitLine:{show:false}},{type:'category',data:dt,gridIndex:1,axisLine:{lineStyle:{color:G}},axisLabel:{show:false},splitLine:{show:false}}];
const yA=[{type:'value',gridIndex:0,splitLine:{lineStyle:{color:G}},axisLabel:{color:S},scale:true},{type:'value',gridIndex:1,splitLine:{show:false},axisLabel:{show:false},axisLine:{show:false}}];
const ser=[{type:'candlestick',data:oh,itemStyle:{color:U,color0:D,borderColor:U,borderColor0:D}},{type:'bar',data:v.map((x,i)=>({value:x,itemStyle:{color:vc[i]}})),xAxisIndex:1,yAxisIndex:1}];
const dzIdx=[0,1];let gi=2,curTop=10+mainH+volH+2;

// MA overlay
if(sel.includes('MA')){[7,25,99].forEach((p,pi)=>{ser.push({type:'line',data:ma(cl,p),name:'MA'+p,symbol:'none',lineStyle:{width:1.2,color:P[pi]},xAxisIndex:0,yAxisIndex:0})})}
// BOLL overlay
if(sel.includes('BOLL')){const b=boll(cl);ser.push({type:'line',data:b.mid,name:'BOLL Mid',symbol:'none',lineStyle:{width:1,color:'#ffc233'}});ser.push({type:'line',data:b.up,name:'BOLL Upper',symbol:'none',lineStyle:{width:1,type:'dashed',color:'#ffc23380'}});ser.push({type:'line',data:b.lo,name:'BOLL Lower',symbol:'none',lineStyle:{width:1,type:'dashed',color:'#ffc23380'}});ser.push({type:'line',data:b.up,name:'Band',symbol:'none',lineStyle:{width:0},areaStyle:{color:'#ffc23310'},stack:'boll'});ser.push({type:'line',data:b.lo,symbol:'none',lineStyle:{width:0},areaStyle:{color:'#ffc23310'},stack:'boll'})}
// VWAP overlay
if(sel.includes('VWAP')){const vw=vwap(r);ser.push({type:'line',data:vw,name:'VWAP',symbol:'none',lineStyle:{width:2,color:'#ffffff'},xAxisIndex:0,yAxisIndex:0})}
// RSI sub-panel
if(hasRSI){const subH=subN===1?18:14;grids.push({left:'8%',right:'4%',top:curTop+'%',height:subH+'%'});xA.push({type:'category',data:dt,gridIndex:gi,axisLine:{lineStyle:{color:G}},axisLabel:{show:false},splitLine:{show:false}});yA.push({type:'value',gridIndex:gi,min:0,max:100,splitLine:{lineStyle:{color:G}},axisLabel:{color:S,fontSize:9}});ser.push({type:'line',data:rsi(cl),name:'RSI(14)',symbol:'none',lineStyle:{width:1.5,color:'#7c4dff'},xAxisIndex:gi,yAxisIndex:gi});dzIdx.push(gi);curTop+=subH+2;gi++}
// MACD sub-panel
if(hasMACD){const subH=subN===1?18:14;grids.push({left:'8%',right:'4%',top:curTop+'%',height:subH+'%'});xA.push({type:'category',data:dt,gridIndex:gi,axisLine:{lineStyle:{color:G}},axisLabel:{color:S,fontSize:9},splitLine:{show:false}});yA.push({type:'value',gridIndex:gi,splitLine:{lineStyle:{color:G}},axisLabel:{color:S,fontSize:9}});const mc=macd(cl);ser.push({type:'bar',data:mc.h.map(v=>({value:v,itemStyle:{color:v>=0?U+'cc':D+'cc'}})),name:'Hist',xAxisIndex:gi,yAxisIndex:gi});ser.push({type:'line',data:mc.m,name:'MACD',symbol:'none',lineStyle:{width:1.2,color:'#5b8ff9'},xAxisIndex:gi,yAxisIndex:gi});ser.push({type:'line',data:mc.s,name:'Signal',symbol:'none',lineStyle:{width:1.2,color:'#ff6b6b'},xAxisIndex:gi,yAxisIndex:gi});dzIdx.push(gi);gi++}

// ATR sub-panel
if(hasATR){const subH=subN===1?18:14;grids.push({left:'8%',right:'4%',top:curTop+'%',height:subH+'%'});xA.push({type:'category',data:dt,gridIndex:gi,axisLine:{lineStyle:{color:G}},axisLabel:{color:S,fontSize:9},splitLine:{show:false}});yA.push({type:'value',gridIndex:gi,splitLine:{lineStyle:{color:G}},axisLabel:{color:S,fontSize:9}});const at=atr(r);ser.push({type:'line',data:at,name:'ATR(14)',symbol:'none',lineStyle:{width:1.5,color:'#ff6b6b'},xAxisIndex:gi,yAxisIndex:gi});dzIdx.push(gi);curTop+=subH+2;gi++}

ic('c-indicators').setOption({backgroundColor:B,animation:false,title:{text:`${s} â€” Indicators`,left:'center',textStyle:{color:T,fontSize:14,fontWeight:700}},tooltip:{trigger:'axis',axisPointer:{type:'cross'},backgroundColor:'#1e1e3d',borderColor:'#2a2a4a',textStyle:{color:T,fontSize:11}},legend:{data:ser.filter(s=>s.name).map(s=>s.name),bottom:0,textStyle:{color:S,fontSize:10}},grid:grids,xAxis:xA,yAxis:yA,series:ser,dataZoom:[{type:'inside',xAxisIndex:dzIdx}]},true);
$('in-st').textContent=`${s} Â· ${sel.join('+')} Â· ${r.length} candles`}catch(e){$('in-st').textContent='Error: '+e.message}}

// OVERLAY â€” multi-asset cross-market
async function lov(){
const syms=[];
for(let i=1;i<=6;i++){const v=$('ov-'+i).value;if(v)syms.push(v)}
if(syms.length<2){$('ov-st').textContent='âš ï¸ Select at least 2 assets';return}
const days=+$('ov-d').value;$('ov-st').textContent='Loading...';
try{const allData=await Promise.all(syms.map(s=>fdata(s,'1d',days)));
function norm(r){const cl=r.map(k=>+k[4]),f=cl[0];return{dates:r.map(k=>fd(k[0],'1d')),vals:cl.map(v=>((v-f)/f)*100)}}
const normed=allData.map(r=>norm(r));
// Use longest date array as x-axis
const dates=normed.reduce((a,b)=>a.dates.length>=b.dates.length?a:b).dates;
// Build display names
const ovNames=syms.map(s=>{for(const mk of Object.values(MKT_SYMS)){const f=mk.find(x=>x.v===s);if(f)return f.l}return s.replace('USDT','')});
const series=normed.map((n,i)=>({name:ovNames[i],type:'line',data:n.vals,symbol:'none',lineStyle:{width:2,color:P[i%P.length]},areaStyle:{color:{type:'linear',x:0,y:0,x2:0,y2:1,colorStops:[{offset:0,color:P[i%P.length]+'20'},{offset:1,color:'transparent'}]}}}));
ic('c-overlay').setOption({backgroundColor:B,animation:false,title:{text:ovNames.join(' vs ')+' (% change)',left:'center',textStyle:{color:T,fontSize:14,fontWeight:700}},tooltip:{trigger:'axis',backgroundColor:'#1e1e3d',borderColor:'#2a2a4a',textStyle:{color:T},formatter:function(p){let s=p[0].axisValue+'<br>';p.forEach(i=>{s+=`<span style="color:${i.color}">â—</span> ${i.seriesName}: ${i.value!==null?i.value.toFixed(2)+'%':'â€”'}<br>`});return s}},legend:{data:ovNames,bottom:4,textStyle:{color:S,fontSize:10}},grid:[{left:'8%',right:'4%',top:'10%',height:'78%'}],xAxis:[{type:'category',data:dates,axisLine:{lineStyle:{color:G}},axisLabel:{color:S,fontSize:9},splitLine:{show:false}}],yAxis:[{type:'value',splitLine:{lineStyle:{color:G}},axisLabel:{color:S,formatter:v=>v.toFixed(0)+'%'}}],series:series,dataZoom:[{type:'inside'}]},true);
const statParts=syms.map((s,i)=>{const r=allData[i],pct=((+r[r.length-1][4]-+r[0][4])/+r[0][4]*100).toFixed(1);return`${ovNames[i]}: ${pct>=0?'+':''}${pct}%`});
$('ov-st').textContent=statParts.join(' Â· ')}catch(e){$('ov-st').textContent='Error: '+e.message}}

// FUNDAMENTALS (3 modes: standard / dcf / estimates)
function lfun(){const mode=$('fn-m').value;
if(mode==='dcf')lfunDCF();
else if(mode==='estimates')lfunEst();
else lfunStd()}

// Standard â€” bar comparison
function lfunStd(){const years=['2021','2022','2023','2024','2025'];
const data={AAPL:{rev:[365.8,394.3,383.3,391.0,420.5]},MSFT:{rev:[168.1,198.3,211.9,245.1,277.0]},GOOGL:{rev:[257.6,282.8,307.4,350.0,381.0]}};
$('fn-s').style.display='none';
ic('c-fundamentals').setOption({backgroundColor:B,animation:true,title:{text:'Revenue Comparison (Billion USD)',left:'center',textStyle:{color:T,fontSize:14,fontWeight:700}},tooltip:{trigger:'axis',backgroundColor:'#1e1e3d',borderColor:'#2a2a4a',textStyle:{color:T},formatter:function(p){let s=p[0].axisValue+'<br>';p.forEach(i=>{s+=`<span style="color:${i.color}">â—</span> ${i.seriesName}: $${i.value}B<br>`});return s}},legend:{data:['AAPL','MSFT','GOOGL'],bottom:4,textStyle:{color:S,fontSize:10}},grid:{left:'8%',right:'4%',top:'14%',bottom:'14%'},xAxis:{type:'category',data:years,axisLine:{lineStyle:{color:G}},axisLabel:{color:S}},yAxis:{type:'value',splitLine:{lineStyle:{color:G}},axisLabel:{color:S,formatter:v=>'$'+v+'B'}},series:[{name:'AAPL',type:'bar',data:data.AAPL.rev,itemStyle:{color:P[0],borderRadius:[4,4,0,0]}},{name:'MSFT',type:'bar',data:data.MSFT.rev,itemStyle:{color:P[1],borderRadius:[4,4,0,0]}},{name:'GOOGL',type:'bar',data:data.GOOGL.rev,itemStyle:{color:P[3],borderRadius:[4,4,0,0]}}]},true);
$('fn-st').textContent='Sample data â€” AAPL vs MSFT vs GOOGL'}

// DCF Gauge â€” sample
function lfunDCF(){$('fn-s').style.display='inline-block';
const sym=$('fn-s').value;
const dcfSample={AAPL:{dcf:198.5,price:178.2},MSFT:{dcf:445.0,price:420.8},GOOGL:{dcf:195.0,price:175.3},TSLA:{dcf:180.0,price:248.5},AMZN:{dcf:210.0,price:192.7},NVDA:{dcf:880.0,price:950.0}};
const d=dcfSample[sym]||{dcf:200,price:180};
const margin=((d.dcf-d.price)/d.dcf*100);const under=margin>0;
const maxV=Math.max(d.dcf,d.price)*1.3;
ic('c-fundamentals').setOption({backgroundColor:B,animation:true,
title:{text:`${sym} â€” DCF Valuation`,left:'center',top:10,textStyle:{color:T,fontSize:15,fontWeight:700}},
series:[{type:'gauge',center:['50%','60%'],radius:'80%',min:0,max:Math.round(maxV),
progress:{show:true,width:22,itemStyle:{color:under?U:D}},
pointer:{show:true,length:'60%',width:6,itemStyle:{color:'#fff'}},
axisLine:{lineStyle:{width:22,color:[[d.dcf/maxV,under?'#1a3a2a':'#3a1a2a'],[1,'#1a1a35']]}},
axisTick:{distance:-28,lineStyle:{color:'#444',width:1}},
splitLine:{distance:-32,lineStyle:{color:'#666',width:2}},
axisLabel:{color:S,fontSize:11,distance:-18,formatter:v=>'$'+Math.round(v)},
anchor:{show:true,size:16,itemStyle:{borderWidth:4,borderColor:under?U:D,color:'#1a1a35'}},
detail:{valueAnimation:true,formatter:v=>'$'+v.toFixed(2),color:T,fontSize:28,fontWeight:700,offsetCenter:[0,'30%']},
title:{show:true,offsetCenter:[0,'46%'],color:S,fontSize:13},
data:[{value:d.price,name:'Stock Price'}],
markPoint:{data:[{x:'50%',y:'82%',symbol:'pin',symbolSize:0,label:{show:true,formatter:`DCF: $${d.dcf.toFixed(2)}`,color:under?U:D,fontSize:14,fontWeight:600}}]}
}]},true);
const tag=under?`Undervalued by ${margin.toFixed(1)}%`:`Overvalued by ${Math.abs(margin).toFixed(1)}%`;
$('fn-st').textContent=`${sym} â€” DCF: $${d.dcf} | Price: $${d.price} | ${tag} (sample data)`}

// Analyst Estimates â€” sample
function lfunEst(){$('fn-s').style.display='inline-block';
const sym=$('fn-s').value;
const estSample={AAPL:{actual:[6.11,6.14,6.42,6.97],est:[7.35,7.80,8.15],years:['2022','2023','2024','2025','2026E','2027E','2028E']},
MSFT:{actual:[9.65,11.07,11.80,13.15],est:[14.50,16.20,17.80],years:['2022','2023','2024','2025','2026E','2027E','2028E']},
GOOGL:{actual:[4.56,5.80,6.52,7.88],est:[8.75,9.60,10.40],years:['2022','2023','2024','2025','2026E','2027E','2028E']},
TSLA:{actual:[1.07,3.12,2.48,2.10],est:[2.85,3.90,5.20],years:['2022','2023','2024','2025','2026E','2027E','2028E']},
AMZN:{actual:[-.27,1.29,2.90,4.47],est:[5.80,7.10,8.50],years:['2022','2023','2024','2025','2026E','2027E','2028E']},
NVDA:{actual:[1.74,4.02,12.96,29.04],est:[35.00,38.50,42.00],years:['2022','2023','2024','2025','2026E','2027E','2028E']}};
const d=estSample[sym]||estSample.AAPL;
const allV=[...d.actual,...d.est];
ic('c-fundamentals').setOption({backgroundColor:B,animation:true,
title:{text:`${sym} â€” EPS: Actual vs Estimates`,left:'center',top:8,textStyle:{color:T,fontSize:15,fontWeight:700}},
tooltip:{trigger:'axis',backgroundColor:'#1e1e3d',borderColor:'#2a2a4a',textStyle:{color:T},formatter:p=>{let s=p[0].axisValue+'<br>';p.forEach(i=>{if(i.value!=null)s+=`<span style="color:${i.color}">â—</span> ${i.seriesName}: $${i.value.toFixed(2)}<br>`});return s}},
legend:{data:['Actual EPS','Estimated EPS'],bottom:4,textStyle:{color:S,fontSize:10}},
grid:{left:'10%',right:'6%',top:'16%',bottom:'14%'},
xAxis:{type:'category',data:d.years,axisLine:{lineStyle:{color:G}},axisLabel:{color:S,fontSize:11},splitLine:{show:false}},
yAxis:{type:'value',splitLine:{lineStyle:{color:G}},axisLabel:{color:S,formatter:v=>'$'+v.toFixed(2)}},
series:[
{name:'Actual EPS',type:'bar',data:[...d.actual,...d.est.map(()=>null)],itemStyle:{color:U,borderRadius:[4,4,0,0]},barWidth:'30%'},
{name:'Estimated EPS',type:'bar',data:[...d.actual.map(()=>null),...d.est],itemStyle:{color:'#5b8ff980',borderColor:'#5b8ff9',borderWidth:1,borderType:'dashed',borderRadius:[4,4,0,0]},barWidth:'30%'}
]},true);
$('fn-st').textContent=`${sym} EPS â€” ${d.actual.length} actual + ${d.est.length} estimates (sample data)`}

// Show/hide symbol selector when mode changes
$('fn-m')?.addEventListener('change',function(){
  const m=this.value;$('fn-s').style.display=m==='standard'?'none':'inline-block';
})

// CRYPTO SECTORS MAP
const CSEC={BTC:'Layer 1',ETH:'Layer 1',SOL:'Layer 1',ADA:'Layer 1',AVAX:'Layer 1',DOT:'Layer 1',NEAR:'Layer 1',SUI:'Layer 1',APT:'Layer 1',TON:'Layer 1',ATOM:'Layer 1',ICP:'Layer 1',ALGO:'Layer 1',HBAR:'Layer 1',FTM:'Layer 1',SEI:'Layer 1',TIA:'Layer 1',INJ:'Layer 1',KAS:'Layer 1',
ARB:'Layer 2',OP:'Layer 2',MATIC:'Layer 2',POL:'Layer 2',STRK:'Layer 2',MANTA:'Layer 2',IMX:'Layer 2',MNT:'Layer 2',ZK:'Layer 2',
UNI:'DeFi',AAVE:'DeFi',MKR:'DeFi',CRV:'DeFi',DYDX:'DeFi',COMP:'DeFi',SNX:'DeFi',SUSHI:'DeFi',LDO:'DeFi',PENDLE:'DeFi',JUP:'DeFi',CAKE:'DeFi',RUNE:'DeFi',ENA:'DeFi',
FET:'AI',RENDER:'AI',TAO:'AI',AGIX:'AI',OCEAN:'AI',WLD:'AI',AKT:'AI',RNDR:'AI',
AXS:'Gaming',SAND:'Gaming',MANA:'Gaming',GALA:'Gaming',ENJ:'Gaming',BEAM:'Gaming',PIXEL:'Gaming',RON:'Gaming',
DOGE:'Meme',SHIB:'Meme',PEPE:'Meme',FLOKI:'Meme',WIF:'Meme',BONK:'Meme',NEIRO:'Meme',NOT:'Meme',DOGS:'Meme',BOME:'Meme',PEOPLE:'Meme',TURBO:'Meme',
LINK:'Infra',GRT:'Infra',FIL:'Infra',AR:'Infra',THETA:'Infra',ANKR:'Infra',PYTH:'Infra',STX:'Infra',W:'Infra',
BNB:'Exchange',OKB:'Exchange',CRO:'Exchange',GT:'Exchange',
XRP:'Payment',XLM:'Payment',LTC:'Payment',BCH:'Payment'};
const EXCL=new Set(['USDT','USDC','DAI','BUSD','TUSD','USDP','FDUSD','USDD','WBTC','WETH','STETH','CBETH','RETH','PAXG']);
function cBase(s){const u=s.toUpperCase();if(u.endsWith('USDT'))return u.slice(0,-4);return u}
function cChg(c){if(c>=5)return'#00d4aa';if(c>=2)return'#33b88a';if(c>=.5)return'#4a8a6a';if(c>-.5)return'#4a4a6a';if(c>-2)return'#8a4a5a';if(c>-5)return'#b83353';return'#ff4757'}

// HEATMAP â€” Crypto Sector Treemap
async function lhm(){$('hm-st').textContent='Loading from Binance...';
try{const lim=+$('hm-l').value,minV=+$('hm-v').value;
const res=await(await fetch('https://api.binance.com/api/v3/ticker/24hr')).json();
let items=res.filter(t=>{if(!t.symbol.endsWith('USDT'))return false;const b=cBase(t.symbol);if(EXCL.has(b))return false;return parseFloat(t.quoteVolume||'0')>=minV}).map(t=>{const b=cBase(t.symbol);return{code:b,chg:parseFloat(t.priceChangePercent||'0'),vol:parseFloat(t.quoteVolume||'0'),price:parseFloat(t.lastPrice||'0'),sector:CSEC[b]||'Other'}}).sort((a,b)=>b.vol-a.vol).slice(0,lim);

// Group by sector
const sm=new Map();items.forEach(i=>{if(!sm.has(i.sector))sm.set(i.sector,[]);sm.get(i.sector).push(i)});
const tree=[...sm.entries()].map(([sec,stocks])=>({name:sec,children:stocks.map(s=>({name:s.code,value:s.vol,itemStyle:{color:cChg(s.chg),borderColor:B,borderWidth:1},_d:{price:s.price,chg:s.chg,vol:s.vol,sector:s.sector}}))}));

ic('c-heatmap').setOption({backgroundColor:B,title:{text:'Crypto Sector Heatmap (24h Change)',left:'center',top:8,textStyle:{color:T,fontSize:15,fontWeight:700}},
tooltip:{formatter:i=>{const d=i.data?._d;if(!d)return'<b>'+i.name+'</b>';const s=d.chg>=0?'+':'';return`<b>${i.name}</b><br>Price: $${d.price.toLocaleString()}<br>Change: <span style="color:${d.chg>=0?U:D}">${s}${d.chg.toFixed(2)}%</span><br>24h Vol: $${(d.vol/1e6).toFixed(1)}M<br>${d.sector}`}},
series:[{type:'treemap',data:tree,width:'94%',height:'84%',top:44,left:'center',roam:false,nodeClick:false,breadcrumb:{show:false},
levels:[{itemStyle:{borderColor:'#333',borderWidth:0,gapWidth:2}},{itemStyle:{borderColor:'#555',borderWidth:2,gapWidth:2},upperLabel:{show:true,height:20,color:S,fontSize:11,fontWeight:'bold',backgroundColor:'transparent'}},{itemStyle:{borderColor:B,borderWidth:1,gapWidth:1},label:{show:true,formatter:p=>{const d=p.data?._d;if(!d)return p.name;const s=d.chg>=0?'+':'';return'{name|'+p.name+'}\n{chg|'+s+d.chg.toFixed(1)+'%}'},rich:{name:{fontSize:12,color:'#fff',fontWeight:'bold',lineHeight:16},chg:{fontSize:10,color:'#ddd',lineHeight:14}},align:'center',verticalAlign:'middle'}}]}]},true);
$('hm-st').textContent=`${items.length} tokens Â· ${sm.size} sectors Â· live from Binance`}catch(e){$('hm-st').textContent='Error: '+e.message}}

// CORRELATION MATRIX
async function lcr(){$('cr-st').textContent='Calculating...';
try{const syms=[...new Set([$('cr-a1').value,$('cr-a2').value,$('cr-a3').value].concat($('cr-a4').value?[$('cr-a4').value]:[]))];
if(syms.length<2){$('cr-st').textContent='âš ï¸ Select at least 2 different assets';return}
const days=+$('cr-d').value;const names=syms.map(s=>s.endsWith('USDT')?cBase(s):s);
// Fetch daily klines for all
const all=await Promise.all(syms.map(s=>fdata(s,'1d',days)));
// Compute daily log returns
const rets=all.map(kl=>{const cl=kl.map(k=>+k[4]);const r=[];for(let i=1;i<cl.length;i++)r.push(cl[i-1]===0?0:Math.log(cl[i]/cl[i-1]));return r});
// Align lengths
const minLen=Math.min(...rets.map(r=>r.length));const aligned=rets.map(r=>r.slice(r.length-minLen));
// Pearson correlation
function pcorr(x,y){const n=x.length;let sx=0,sy=0,sxy=0,sx2=0,sy2=0;for(let i=0;i<n;i++){sx+=x[i];sy+=y[i];sxy+=x[i]*y[i];sx2+=x[i]*x[i];sy2+=y[i]*y[i]}const num=n*sxy-sx*sy;const den=Math.sqrt((n*sx2-sx*sx)*(n*sy2-sy*sy));return den===0?0:num/den}
const n=syms.length;const mat=[];for(let i=0;i<n;i++){mat[i]=[];for(let j=0;j<n;j++){mat[i][j]=i===j?1:Math.round(pcorr(aligned[i],aligned[j])*1000)/1000}}
// Build heatmap data [x, y, value]
const hd=[];for(let i=0;i<n;i++)for(let j=0;j<n;j++)hd.push([j,n-1-i,mat[i][j]]);

ic('c-corr').setOption({backgroundColor:B,title:{text:`Correlation Matrix (${days}d daily returns)`,left:'center',top:8,textStyle:{color:T,fontSize:15,fontWeight:700}},
tooltip:{position:'top',formatter:p=>{const[x,ry,v]=p.data;const y=n-1-ry;if(x===y)return`<b>${names[x]}</b> (self)`;const s=v>=0?'+':'';const c=v>=0?U:D;return`<b>${names[y]}</b> vs <b>${names[x]}</b><br>Correlation: <span style="color:${c}">${s}${v.toFixed(3)}</span>`}},
grid:{left:80,right:80,top:50,bottom:80},
xAxis:{type:'category',data:names,position:'bottom',axisLine:{show:false},axisTick:{show:false},axisLabel:{color:S,fontSize:12},splitArea:{show:false}},
yAxis:{type:'category',data:[...names].reverse(),axisLine:{show:false},axisTick:{show:false},axisLabel:{color:S,fontSize:12},splitArea:{show:false}},
visualMap:{min:-1,max:1,calculable:false,orient:'vertical',right:6,top:'center',inRange:{color:[D,'#6a3040','#4a4a6a','#3a6a50',U]},textStyle:{color:S},text:['+1','-1']},
series:[{type:'heatmap',data:hd,label:{show:true,formatter:p=>p.data[2]===1?'1.00':p.data[2].toFixed(2),color:T,fontSize:n>5?10:13},emphasis:{itemStyle:{borderColor:'#fff',borderWidth:2}},itemStyle:{borderColor:B,borderWidth:2}}]},true);
$('cr-st').textContent=`${names.join(' Ã— ')} Â· ${minLen} days Â· Pearson r`}catch(e){$('cr-st').textContent='Error: '+e.message}}

// WRB SCORING
function detectWRB(klines,lb=5,sens=1.5){
const bars=klines.map(k=>({o:+k[1],h:+k[2],l:+k[3],c:+k[4],v:+k[5],t:k[0]}));
const wrb=[],gaps=[];
for(let i=lb;i<bars.length;i++){
const b=bars[i],body=Math.abs(b.c-b.o);
let avgBody=0;for(let j=i-lb;j<i;j++)avgBody+=Math.abs(bars[j].c-bars[j].o);avgBody/=lb;
if(body>avgBody*sens){
const bull=b.c>b.o;wrb.push({idx:i,bull,body});
// Check for hidden gap (no overlap with prev candle body)
const prev=bars[i-1],prevHi=Math.max(prev.o,prev.c),prevLo=Math.min(prev.o,prev.c);
const curHi=Math.max(b.o,b.c),curLo=Math.min(b.o,b.c);
if(curLo>prevHi||curHi<prevLo){
// Check if gap zone still active (not filled by later candles)
const gapTop=bull?curLo:curHi,gapBot=bull?prevHi:prevLo;
let filled=false,pro=false;
// Simple pro check: volume > 1.5x avg and strong direction
const avgVol=bars.slice(Math.max(0,i-20),i).reduce((a,x)=>a+x.v,0)/Math.min(20,i);
if(b.v>avgVol*1.2&&body>avgBody*2)pro=true;
// Check if filled by subsequent bars
for(let j=i+1;j<bars.length;j++){const fb=bars[j];if(bull&&fb.l<gapBot){filled=true;break}if(!bull&&fb.h>gapTop){filled=true;break}}
gaps.push({idx:i,bull,top:Math.max(gapTop,gapBot),bot:Math.min(gapTop,gapBot),filled,pro})
}}}
return{wrb,gaps,bars}}

async function lwrb(){const s=$('wrb-s').value,tf=$('wrb-t').value,l=+$('wrb-l').value,m=$('wrb-m')?.value||'crypto';$('wrb-st').textContent='Analyzing...';
try{const r=await fdata(s,tf,l),dt=r.map(k=>fd(k[0],tf)),oh=r.map(k=>[+k[1],+k[4],+k[3],+k[2]]),v=r.map(k=>+k[5]),vc=r.map(k=>+k[4]>=+k[1]?U+'80':D+'80');
const w=detectWRB(r);
// WRB diamonds with labels â€” coord uses category string, not index
const wrbMark=w.wrb.map(x=>({
coord:[dt[x.idx],x.bull?w.bars[x.idx].h*1.008:w.bars[x.idx].l*0.992],
symbol:'diamond',
symbolSize:10,
itemStyle:{color:'#7c4dff'},
label:{show:true,formatter:t(x.bull?'wrb_bull':'wrb_bear'),color:x.bull?U:D,fontSize:9,fontWeight:'bold',position:x.bull?'top':'bottom',offset:[0,x.bull?-2:2]}
}));
// Gap zones â€” active gaps extend to chart right edge
const gapAreas=w.gaps.filter(g=>!g.filled).map(g=>{
const color=g.pro?'#ffc23335':(g.bull?'#00d4aa25':'#ff475725');
return[{xAxis:dt[g.idx],yAxis:g.top,itemStyle:{color}},{xAxis:dt[dt.length-1],yAxis:g.bot}]
});
// Pro signals â€” coord uses category string
const proData=w.gaps.filter(g=>g.pro&&!g.filled).map(g=>({value:[dt[g.idx],g.bull?w.bars[g.idx].l*0.996:w.bars[g.idx].h*1.004]}));

const dispName=s.endsWith('USDT')?s:MKT_SYMS[m]?.find(x=>x.v===s)?.l||s;
ic('c-wrb').setOption({backgroundColor:B,animation:false,
title:{text:`${dispName} â€” ${tf} WRB/HG`,left:'center',textStyle:{color:T,fontSize:15,fontWeight:700}},
tooltip:{trigger:'axis',axisPointer:{type:'cross'},backgroundColor:'#1e1e3d',borderColor:'#2a2a4a',textStyle:{color:T}},
legend:{data:['Pro Signal'],bottom:4,right:16,textStyle:{color:S,fontSize:10}},
grid:[{left:'8%',right:'4%',top:'10%',height:'54%'},{left:'8%',right:'4%',top:'68%',height:'14%'}],
xAxis:[{type:'category',data:dt,gridIndex:0,axisLine:{lineStyle:{color:G}},axisLabel:{color:S,fontSize:9},splitLine:{show:false}},
{type:'category',data:dt,gridIndex:1,axisLine:{lineStyle:{color:G}},axisLabel:{show:false},splitLine:{show:false}}],
yAxis:[{type:'value',gridIndex:0,splitLine:{lineStyle:{color:G}},axisLabel:{color:S},scale:true},
{type:'value',gridIndex:1,splitLine:{show:false},axisLabel:{show:false},axisLine:{show:false}}],
series:[
{type:'candlestick',data:oh,itemStyle:{color:U,color0:D,borderColor:U,borderColor0:D},
markPoint:{data:wrbMark,animation:false},
markArea:{silent:true,data:gapAreas}},
{name:'Pro Signal',type:'scatter',data:proData,symbol:'diamond',symbolSize:14,itemStyle:{color:'#ffc233',borderColor:'#fff',borderWidth:2},z:10},
{type:'bar',data:v.map((x,i)=>({value:x,itemStyle:{color:vc[i]}})),xAxisIndex:1,yAxisIndex:1}
],
dataZoom:[{type:'inside',xAxisIndex:[0,1]}]
},true);

const activeG=w.gaps.filter(g=>!g.filled).length,proG=w.gaps.filter(g=>g.pro&&!g.filled).length;
$('wrb-st').textContent=`WRB: ${w.wrb.length} | Gaps: ${w.gaps.length} (Active: ${activeG}) | Pro: ${proG} Â· ${r.length} candles`
}catch(e){$('wrb-st').textContent='Error: '+e.message}}

function $(id){return document.getElementById(id)}

// Fill all symbol selects on init
function initSelects(){
// Update market selectors first
updateMarketSelectors();
// Single-symbol tabs: kl, vp, in, wrb
['kl','vp','in','wrb'].forEach(p=>{
  const m=$(p+'-m')?.value||'crypto';
  const syms=MKT_SYMS[m]||MKT_SYMS.crypto;
  const sel=$(p+'-s');
  if(sel)sel.innerHTML=syms.map(s=>`<option value="${s.v}">${s.l}</option>`).join('');
});
// Overlay: ov-1..ov-6 â€” all markets merged
const allOvSyms=[];
const mktLabels={crypto:'ğŸ”—',us_stock:'ğŸ‡ºğŸ‡¸',a_stock:'ğŸ‡¨ğŸ‡³',commodity:'ğŸ¥‡',index:'ğŸ“Š'};
Object.entries(MKT_SYMS).forEach(([mk,syms])=>{syms.forEach(s=>{allOvSyms.push({v:s.v,l:(mktLabels[mk]||'')+' '+s.l})})});
const ovDefaults=['BTCUSDT','AAPL','XAUUSD','','',''];
for(let i=1;i<=6;i++){
  const sel=$('ov-'+i);
  const none=i>2?'<option value="">â€”</option>':'';
  sel.innerHTML=none+allOvSyms.map(s=>`<option value="${s.v}"${s.v===ovDefaults[i-1]?' selected':''}>${s.l}</option>`).join('');
}
// Correlation: cr-a1..a4 â€” crypto with extra choices
const crSyms=[...MKT_SYMS.crypto,{v:'DOGEUSDT',l:'DOGE/USDT'},{v:'XRPUSDT',l:'XRP/USDT'},{v:'ADAUSDT',l:'ADA/USDT'},{v:'AVAXUSDT',l:'AVAX/USDT'}];
const crDefs=['BTCUSDT','ETHUSDT','SOLUSDT',''];
['cr-a1','cr-a2','cr-a3','cr-a4'].forEach((id,i)=>{
  const none=i===3?'<option value="">â€” none â€”</option>':'';
  $(id).innerHTML=none+crSyms.map(s=>`<option value="${s.v}"${s.v===crDefs[i]?' selected':''}>${s.l}</option>`).join('');
});
}
initSelects();
// Apply initial language
setLang('zh');
// Auto-load first tab
lkl();

// ===== AI CHAT =====
const CHAT_API = 'https://gainlab-api.asher-sun.workers.dev/api/chat';
let chatMessages = []; // conversation history (trimmed to last 20 messages to limit payload size)
let chatBusy = false;

// Strip <think>...</think> from text (including across chunks)
let chatThinkBuf = '';
function filterThink(raw) {
  // Accumulate raw text and strip think blocks
  let result = '';
  let s = chatThinkBuf + raw;
  chatThinkBuf = '';
  // Remove complete think blocks
  s = s.replace(/<think>[\s\S]*?<\/think>/g, '');
  // If partial open tag at end, hold it in buffer
  const openIdx = s.lastIndexOf('<think>');
  if (openIdx !== -1) {
    chatThinkBuf = s.slice(openIdx);
    s = s.slice(0, openIdx);
  }
  return s;
}

function chatScrollBottom() {
  const el = document.getElementById('chat-messages');
  if (el) el.scrollTop = el.scrollHeight;
}

function chatAddMsg(role, text) {
  const el = document.getElementById('chat-messages');
  const div = document.createElement('div');
  div.className = 'chat-msg ' + role;
  const label = document.createElement('div');
  label.className = 'chat-msg-label';
  label.textContent = role === 'user' ? 'You' : 'GainLab AI';
  const body = document.createElement('div');
  body.className = 'chat-msg-body';
  body.textContent = text;
  div.appendChild(label);
  div.appendChild(body);
  el.appendChild(div);
  chatScrollBottom();
  return body; // return body so we can update it
}

function chatAddTyping() {
  const el = document.getElementById('chat-messages');
  const div = document.createElement('div');
  div.className = 'chat-msg ai';
  div.id = 'chat-typing-indicator';
  const label = document.createElement('div');
  label.className = 'chat-msg-label';
  label.textContent = 'GainLab AI';
  const typing = document.createElement('div');
  typing.className = 'chat-typing';
  typing.innerHTML = '<span></span><span></span><span></span>';
  div.appendChild(label);
  div.appendChild(typing);
  el.appendChild(div);
  chatScrollBottom();
  return div;
}

function chatSetBusy(busy) {
  chatBusy = busy;
  const inp = document.getElementById('chat-input');
  const btn = document.getElementById('chat-send-btn');
  const presets = document.querySelectorAll('.chat-preset-btn');
  if (inp) inp.disabled = busy;
  if (btn) btn.disabled = busy;
  presets.forEach(b => b.disabled = busy);
}

async function sendChatMessage(text) {
  if (chatBusy || !text.trim()) return;
  // Init chat on first use (show welcome if empty)
  const msgsEl = document.getElementById('chat-messages');
  if (!msgsEl) return;

  // Add user message to UI
  chatAddMsg('user', text);
  // Add to history (keep last 20 messages to avoid unbounded growth)
  chatMessages.push({ role: 'user', content: text });
  if (chatMessages.length > 20) chatMessages = chatMessages.slice(-20);
  // Clear input
  const inp = document.getElementById('chat-input');
  if (inp) inp.value = '';
  chatSetBusy(true);

  // Typing indicator
  const typingEl = chatAddTyping();

  // AI message body (will replace typing indicator)
  let aiMsgBody = null;
  let aiMsgDiv = null;
  let accumulated = ''; // full text accumulated
  let toolCallsAcc = {}; // accumulate tool calls by index
  chatThinkBuf = '';

  try {
    const resp = await fetch(CHAT_API, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ messages: chatMessages })
    });

    if (!resp.ok) {
      throw new Error('API error: ' + resp.status);
    }

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buf = '';
    let done = false;

    while (!done) {
      const { value, done: streamDone } = await reader.read();
      done = streamDone;
      if (value) buf += decoder.decode(value, { stream: !done });

      // Process complete lines
      const lines = buf.split('\n');
      buf = lines.pop(); // keep incomplete last line

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || trimmed === 'data: [DONE]') continue;
        if (!trimmed.startsWith('data: ')) continue;
        const jsonStr = trimmed.slice(6);
        let chunk;
        try { chunk = JSON.parse(jsonStr); } catch { continue; }

        const delta = chunk?.choices?.[0]?.delta;
        if (!delta) continue;

        // Handle text content
        if (delta.content) {
          const filtered = filterThink(delta.content);
          if (filtered) {
            accumulated += filtered;
            // Create AI msg bubble if not yet
            if (!aiMsgDiv) {
              typingEl.remove();
              aiMsgDiv = document.createElement('div');
              aiMsgDiv.className = 'chat-msg ai';
              const lbl = document.createElement('div');
              lbl.className = 'chat-msg-label';
              lbl.textContent = 'GainLab AI';
              aiMsgBody = document.createElement('div');
              aiMsgBody.className = 'chat-msg-body';
              aiMsgDiv.appendChild(lbl);
              aiMsgDiv.appendChild(aiMsgBody);
              msgsEl.appendChild(aiMsgDiv);
            }
            aiMsgBody.textContent = accumulated;
            chatScrollBottom();
          }
        }

        // Handle tool calls
        if (delta.tool_calls) {
          for (const tc of delta.tool_calls) {
            const idx = tc.index ?? 0;
            if (!toolCallsAcc[idx]) toolCallsAcc[idx] = { id: '', name: '', args: '' };
            if (tc.id) toolCallsAcc[idx].id = tc.id;
            if (tc.function?.name) toolCallsAcc[idx].name = tc.function.name;
            if (tc.function?.arguments) toolCallsAcc[idx].args += tc.function.arguments;
          }
        }
      }
    }

    // Flush remaining think buffer
    const leftover = filterThink('');
    if (leftover) { accumulated += leftover; if (aiMsgBody) aiMsgBody.textContent = accumulated; }

    // Handle accumulated tool calls
    for (const [idx, tc] of Object.entries(toolCallsAcc)) {
      if (!tc.name) continue;
      // Create AI bubble if not yet (tool-only response)
      if (!aiMsgDiv) {
        typingEl.remove();
        aiMsgDiv = document.createElement('div');
        aiMsgDiv.className = 'chat-msg ai';
        const lbl = document.createElement('div');
        lbl.className = 'chat-msg-label';
        lbl.textContent = 'GainLab AI';
        aiMsgBody = document.createElement('div');
        aiMsgBody.className = 'chat-msg-body';
        aiMsgBody.textContent = t('chat_thinking');
        aiMsgDiv.appendChild(lbl);
        aiMsgDiv.appendChild(aiMsgBody);
        msgsEl.appendChild(aiMsgDiv);
      }
      // Show tool call tag
      let parsedArgs = {};
      try { parsedArgs = JSON.parse(tc.args); } catch {}
      const tag = document.createElement('div');
      tag.className = 'chat-tool-tag';
      const paramStr = Object.entries(parsedArgs).slice(0, 3).map(([k,v]) => `${k}=${JSON.stringify(v)}`).join(', ');
      const ttName = document.createElement('span'); ttName.className = 'tt-name'; ttName.textContent = 'âš™ï¸ ' + tc.name;
      const ttParams = document.createElement('span'); ttParams.className = 'tt-params'; ttParams.textContent = '(' + paramStr + ')';
      tag.appendChild(ttName); tag.appendChild(ttParams);
      aiMsgDiv.appendChild(tag);
      const status = document.createElement('div');
      status.className = 'chat-tool-status';
      status.textContent = 'â³ Rendering chart...';
      aiMsgDiv.appendChild(status);
      chatScrollBottom();
      // Execute tool and render chart (embedded in aiMsgDiv)
      try {
        const result = await chatExecuteTool(tc.name, parsedArgs, aiMsgDiv);
        status.textContent = 'âœ… Chart rendered' + (result ? ' â€” ' + result : '');
        // Update chart status bar
        const statusBar = document.getElementById('chat-chart-status');
        if (statusBar && result) statusBar.textContent = result;
        // Mobile: auto-switch to chart tab
        if (window.innerWidth <= 800) { chatMobileTab('chart'); }
      } catch (toolErr) {
        status.textContent = 'âŒ Error: ' + toolErr.message;
      }
      chatScrollBottom();
    }

    // Remove typing if nothing rendered yet
    if (!aiMsgDiv) {
      typingEl.remove();
      // Show fallback
      const body = chatAddMsg('ai', '(No response)');
    } else {
      // Add AI reply to history
      chatMessages.push({ role: 'assistant', content: accumulated || t('chat_thinking') });
    }

  } catch (err) {
    typingEl.remove();
    chatAddMsg('ai', 'âš ï¸ Error: ' + err.message);
  }

  chatSetBusy(false);
  chatScrollBottom();
}

function chatMobileTab(tab) {
  const main = document.querySelector('.chat-main');
  const tabChart = document.getElementById('chat-mtab-chart');
  const tabConv = document.getElementById('chat-mtab-conv');
  if (tab === 'conv') {
    main.classList.add('show-conv');
    tabChart.classList.remove('active');
    tabConv.classList.add('active');
  } else {
    main.classList.remove('show-conv');
    tabChart.classList.add('active');
    tabConv.classList.remove('active');
  }
  // Resize chart when switching back to chart tab
  if (tab === 'chart') {
    const chartEl = document.getElementById('c-chat-main');
    if (chartEl && ch['c-chat-main']) {
      setTimeout(() => ch['c-chat-main'].resize(), 50);
    }
  }
}

function chatSend() {
  const inp = document.getElementById('chat-input');
  if (inp && inp.value.trim()) sendChatMessage(inp.value.trim());
}

// ===== CHART TOOLBAR =====

function chatToolbarUpdateSymbols() {
  const market = document.getElementById('ct-market').value;
  const syms = MKT_SYMS[market] || MKT_SYMS.crypto;
  const sel = document.getElementById('ct-symbol');
  sel.innerHTML = syms.map(s => `<option value="${s.v}">${s.l}</option>`).join('');
}

function chatTfSelect(btn) {
  document.querySelectorAll('.chat-tf-btn').forEach(b => b.classList.remove('on'));
  btn.classList.add('on');
}

function chatIndToggle(chip) {
  chip.classList.toggle('on');
}

async function chatToolbarGo() {
  const market = document.getElementById('ct-market').value;
  const symbol = document.getElementById('ct-symbol').value;
  const tf = document.querySelector('.chat-tf-btn.on')?.dataset.tf || '1d';
  const inds = [...document.querySelectorAll('.chat-ind-chip.on')].map(c => c.dataset.ind);
  const statusEl = document.getElementById('chat-chart-status');
  if (statusEl) statusEl.textContent = 'â³ Loading...';
  try {
    let result;
    if (inds.length > 0) {
      result = await chatExecuteTool('gainlab_indicators', { symbol, market, timeframe: tf, indicators: inds });
    } else {
      result = await chatExecuteTool('gainlab_kline', { symbol, market, timeframe: tf, limit: 100 });
    }
    if (statusEl) statusEl.textContent = result || '';
  } catch(e) {
    if (statusEl) statusEl.textContent = 'âŒ ' + (e.message || e);
  }
}

// ===== CHAT TOOL EXECUTION =====

// Normalize symbol: AI may say "BTC" but fdata needs "BTCUSDT"
function chatNormSymbol(symbol, market) {
  if (!symbol) return symbol;
  const aliases = {
    'bitcoin': 'BTCUSDT', 'btc': 'BTCUSDT',
    'ethereum': 'ETHUSDT', 'eth': 'ETHUSDT',
    'solana': 'SOLUSDT', 'sol': 'SOLUSDT',
    'bnb': 'BNBUSDT',
    'gold': 'XAUUSD', 'xau': 'XAUUSD',
    'silver': 'XAGUSD', 'xag': 'XAGUSD',
    'moutai': '600519', 'guizhou moutai': '600519',
    'apple': 'AAPL', 'microsoft': 'MSFT', 'nvidia': 'NVDA',
    'tesla': 'TSLA', 'amazon': 'AMZN', 'google': 'GOOGL',
    'spy': 'SPY', 'qqq': 'QQQ',
    's&p 500': 'SPY', 'nasdaq': 'QQQ'
  };
  const lower = symbol.toLowerCase();
  if (aliases[lower]) return aliases[lower];
  if (market === 'crypto' && !symbol.endsWith('USDT') && !symbol.endsWith('BTC') && !/^XA[UG]/.test(symbol)) {
    return symbol.toUpperCase() + 'USDT';
  }
  return symbol.toUpperCase();
}

// Execute a tool call from the AI and render chart in the fixed #c-chat-main container
async function chatExecuteTool(toolName, args, msgDiv) {
  // Show chart container, hide empty placeholder
  const chartEl = document.getElementById('c-chat-main');
  const emptyEl = document.getElementById('chat-chart-empty');
  chartEl.style.display = 'block';
  if (emptyEl) emptyEl.style.display = 'none';

  // Initialize or reuse ECharts instance
  if (!ch['c-chat-main']) {
    ch['c-chat-main'] = echarts.init(chartEl);
    window.addEventListener('resize', () => { if (ch['c-chat-main']) ch['c-chat-main'].resize(); });
  }
  const chart = ch['c-chat-main'];

  if (toolName === 'gainlab_kline') {
    const sym = chatNormSymbol(args.symbol, args.market);
    const tf = args.timeframe || args.interval || '1d';
    const lim = args.limit || 100;
    let r; try { r = await fdata(sym, tf, lim); } catch(e) { throw new Error('Failed to load ' + sym + ' data: ' + e.message); }
    const dt = r.map(k => fd(k[0], tf));
    const oh = r.map(k => [+k[1], +k[4], +k[3], +k[2]]);
    const v = r.map(k => +k[5]);
    const vc = r.map(k => +k[4] >= +k[1] ? U + '80' : D + '80');
    const la = r[r.length - 1];
    const pc = ((+la[4] - +la[1]) / +la[1] * 100).toFixed(2);
    const title = sym + ' â€” ' + tf;
    chart.setOption({
      backgroundColor: B, animation: false,
      title: { text: title, left: 'center', textStyle: { color: T, fontSize: 14, fontWeight: 700 } },
      tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, backgroundColor: '#1e1e3d', borderColor: '#2a2a4a', textStyle: { color: T } },
      grid: [{ left: '8%', right: '4%', top: '10%', height: '56%' }, { left: '8%', right: '4%', top: '70%', height: '18%' }],
      xAxis: [
        { type: 'category', data: dt, gridIndex: 0, axisLine: { lineStyle: { color: G } }, axisLabel: { color: S, fontSize: 9 }, splitLine: { show: false } },
        { type: 'category', data: dt, gridIndex: 1, axisLine: { lineStyle: { color: G } }, axisLabel: { show: false }, splitLine: { show: false } }
      ],
      yAxis: [
        { type: 'value', gridIndex: 0, splitLine: { lineStyle: { color: G } }, axisLabel: { color: S }, scale: true },
        { type: 'value', gridIndex: 1, splitLine: { show: false }, axisLabel: { show: false }, axisLine: { show: false } }
      ],
      series: [
        { type: 'candlestick', data: oh, itemStyle: { color: U, color0: D, borderColor: U, borderColor0: D } },
        { type: 'bar', data: v.map((x, i) => ({ value: x, itemStyle: { color: vc[i] } })), xAxisIndex: 1, yAxisIndex: 1 }
      ],
      dataZoom: [{ type: 'inside', xAxisIndex: [0, 1] }]
    }, true);
    return sym + ' ' + tf + ' K-line rendered. Last: ' + (+la[4]).toLocaleString() + ' (' + (pc >= 0 ? '+' : '') + pc + '%)';
  }

  if (toolName === 'gainlab_overlay') {
    const symbols = (args.symbols || [args.symbol]).filter(Boolean);
    const markets = args.markets || [];
    const tf = args.timeframe || '1d';
    const lim = args.limit || 180;
    const normSyms = symbols.map((s, i) => chatNormSymbol(s, markets[i] || args.market || 'crypto'));
    let allData; try { allData = await Promise.all(normSyms.map(s => fdata(s, tf, lim))); } catch(e) { throw new Error('Failed to load overlay data: ' + e.message); }
    function norm(r) { const cl = r.map(k => +k[4]), f = cl[0]; return { dates: r.map(k => fd(k[0], tf)), vals: cl.map(v => ((v - f) / f) * 100) }; }
    const normed = allData.map(r => norm(r));
    const dates = normed.reduce((a, b) => a.dates.length >= b.dates.length ? a : b).dates;
    const names = normSyms.map(s => { for (const mk of Object.values(MKT_SYMS)) { const f = mk.find(x => x.v === s); if (f) return f.l; } return s.replace('USDT', ''); });
    const series = normed.map((n, i) => ({
      name: names[i], type: 'line', data: n.vals, symbol: 'none',
      lineStyle: { width: 2, color: P[i % P.length] },
      areaStyle: { color: { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{ offset: 0, color: P[i % P.length] + '20' }, { offset: 1, color: 'transparent' }] } }
    }));
    chart.setOption({
      backgroundColor: B, animation: false,
      title: { text: names.join(' vs ') + ' (% change)', left: 'center', textStyle: { color: T, fontSize: 14, fontWeight: 700 } },
      tooltip: { trigger: 'axis', backgroundColor: '#1e1e3d', borderColor: '#2a2a4a', textStyle: { color: T }, formatter: function(p) { let s = p[0].axisValue + '<br>'; p.forEach(i => { s += `<span style="color:${i.color}">â—</span> ${i.seriesName}: ${i.value !== null ? i.value.toFixed(2) + '%' : 'â€”'}<br>`; }); return s; } },
      legend: { data: names, bottom: 4, textStyle: { color: S, fontSize: 10 } },
      grid: [{ left: '8%', right: '4%', top: '10%', height: '78%' }],
      xAxis: [{ type: 'category', data: dates, axisLine: { lineStyle: { color: G } }, axisLabel: { color: S, fontSize: 9 }, splitLine: { show: false } }],
      yAxis: [{ type: 'value', splitLine: { lineStyle: { color: G } }, axisLabel: { color: S, formatter: v => v.toFixed(0) + '%' } }],
      series: series, dataZoom: [{ type: 'inside' }]
    }, true);
    const statParts = normSyms.map((s, i) => { const r = allData[i]; const pct = ((+r[r.length - 1][4] - +r[0][4]) / +r[0][4] * 100).toFixed(1); return names[i] + ': ' + (pct >= 0 ? '+' : '') + pct + '%'; });
    return 'Overlay chart rendered: ' + statParts.join(', ');
  }

  if (toolName === 'gainlab_indicators') {
    const sym = chatNormSymbol(args.symbol, args.market);
    const tf = args.timeframe || '1d';
    const sel = args.indicators || ['MA', 'RSI', 'MACD'];
    let r; try { r = await fdata(sym, tf, 120); } catch(e) { throw new Error('Failed to load ' + sym + ' data: ' + e.message); }
    const dt = r.map(k => fd(k[0], tf));
    const cl = r.map(k => +k[4]);
    const oh = r.map(k => [+k[1], +k[4], +k[3], +k[2]]);
    const v = r.map(k => +k[5]);
    const vc = r.map(k => +k[4] >= +k[1] ? U + '80' : D + '80');
    const hasRSI = sel.includes('RSI'), hasMACD = sel.includes('MACD'), hasATR = sel.includes('ATR');
    let subN = 0; if (hasRSI) subN++; if (hasMACD) subN++; if (hasATR) subN++;
    const mainH = subN === 0 ? 52 : subN === 1 ? 40 : subN === 2 ? 34 : 28, volH = 8;
    const grids = [{ left: '8%', right: '4%', top: '8%', height: mainH + '%' }, { left: '8%', right: '4%', top: (10 + mainH) + '%', height: volH + '%' }];
    const xA = [
      { type: 'category', data: dt, gridIndex: 0, axisLine: { lineStyle: { color: G } }, axisLabel: { color: S, fontSize: 9 }, splitLine: { show: false } },
      { type: 'category', data: dt, gridIndex: 1, axisLine: { lineStyle: { color: G } }, axisLabel: { show: false }, splitLine: { show: false } }
    ];
    const yA = [
      { type: 'value', gridIndex: 0, splitLine: { lineStyle: { color: G } }, axisLabel: { color: S }, scale: true },
      { type: 'value', gridIndex: 1, splitLine: { show: false }, axisLabel: { show: false }, axisLine: { show: false } }
    ];
    const ser = [
      { type: 'candlestick', data: oh, itemStyle: { color: U, color0: D, borderColor: U, borderColor0: D } },
      { type: 'bar', data: v.map((x, i) => ({ value: x, itemStyle: { color: vc[i] } })), xAxisIndex: 1, yAxisIndex: 1 }
    ];
    const dzIdx = [0, 1]; let gi = 2, curTop = 10 + mainH + volH + 2;
    if (sel.includes('MA')) { [7, 25, 99].forEach((p, pi) => { ser.push({ type: 'line', data: ma(cl, p), name: 'MA' + p, symbol: 'none', lineStyle: { width: 1.2, color: P[pi] }, xAxisIndex: 0, yAxisIndex: 0 }); }); }
    if (sel.includes('BOLL')) { const bb = boll(cl); ser.push({ type: 'line', data: bb.mid, name: 'BOLL Mid', symbol: 'none', lineStyle: { width: 1, color: '#ffc233' } }); ser.push({ type: 'line', data: bb.up, name: 'BOLL Upper', symbol: 'none', lineStyle: { width: 1, type: 'dashed', color: '#ffc23380' } }); ser.push({ type: 'line', data: bb.lo, name: 'BOLL Lower', symbol: 'none', lineStyle: { width: 1, type: 'dashed', color: '#ffc23380' } }); }
    if (sel.includes('VWAP')) { const vw = vwap(r); ser.push({ type: 'line', data: vw, name: 'VWAP', symbol: 'none', lineStyle: { width: 2, color: '#ffffff' }, xAxisIndex: 0, yAxisIndex: 0 }); }
    if (hasRSI) { const subH = subN === 1 ? 18 : 14; grids.push({ left: '8%', right: '4%', top: curTop + '%', height: subH + '%' }); xA.push({ type: 'category', data: dt, gridIndex: gi, axisLine: { lineStyle: { color: G } }, axisLabel: { show: false }, splitLine: { show: false } }); yA.push({ type: 'value', gridIndex: gi, min: 0, max: 100, splitLine: { lineStyle: { color: G } }, axisLabel: { color: S, fontSize: 9 } }); ser.push({ type: 'line', data: rsi(cl), name: 'RSI(14)', symbol: 'none', lineStyle: { width: 1.5, color: '#7c4dff' }, xAxisIndex: gi, yAxisIndex: gi }); dzIdx.push(gi); curTop += subH + 2; gi++; }
    if (hasMACD) { const subH = subN === 1 ? 18 : 14; grids.push({ left: '8%', right: '4%', top: curTop + '%', height: subH + '%' }); xA.push({ type: 'category', data: dt, gridIndex: gi, axisLine: { lineStyle: { color: G } }, axisLabel: { color: S, fontSize: 9 }, splitLine: { show: false } }); yA.push({ type: 'value', gridIndex: gi, splitLine: { lineStyle: { color: G } }, axisLabel: { color: S, fontSize: 9 } }); const mc = macd(cl); ser.push({ type: 'bar', data: mc.h.map(v => ({ value: v, itemStyle: { color: v >= 0 ? U + 'cc' : D + 'cc' } })), name: 'Hist', xAxisIndex: gi, yAxisIndex: gi }); ser.push({ type: 'line', data: mc.m, name: 'MACD', symbol: 'none', lineStyle: { width: 1.2, color: '#5b8ff9' }, xAxisIndex: gi, yAxisIndex: gi }); ser.push({ type: 'line', data: mc.s, name: 'Signal', symbol: 'none', lineStyle: { width: 1.2, color: '#ff6b6b' }, xAxisIndex: gi, yAxisIndex: gi }); dzIdx.push(gi); gi++; }
    if (hasATR) { const subH = subN === 1 ? 18 : 14; grids.push({ left: '8%', right: '4%', top: curTop + '%', height: subH + '%' }); xA.push({ type: 'category', data: dt, gridIndex: gi, axisLine: { lineStyle: { color: G } }, axisLabel: { color: S, fontSize: 9 }, splitLine: { show: false } }); yA.push({ type: 'value', gridIndex: gi, splitLine: { lineStyle: { color: G } }, axisLabel: { color: S, fontSize: 9 } }); const at = atr(r); ser.push({ type: 'line', data: at, name: 'ATR(14)', symbol: 'none', lineStyle: { width: 1.5, color: '#ff6b6b' }, xAxisIndex: gi, yAxisIndex: gi }); dzIdx.push(gi); curTop += subH + 2; gi++; }
    chart.setOption({
      backgroundColor: B, animation: false,
      title: { text: sym + ' â€” ' + sel.join('+'), left: 'center', textStyle: { color: T, fontSize: 14, fontWeight: 700 } },
      tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, backgroundColor: '#1e1e3d', borderColor: '#2a2a4a', textStyle: { color: T, fontSize: 11 } },
      legend: { data: ser.filter(s => s.name).map(s => s.name), bottom: 0, textStyle: { color: S, fontSize: 10 } },
      grid: grids, xAxis: xA, yAxis: yA, series: ser, dataZoom: [{ type: 'inside', xAxisIndex: dzIdx }]
    }, true);
    return sym + ' indicators rendered: ' + sel.join(', ');
  }

  if (toolName === 'gainlab_fundamentals') {
    const sym = (args.symbol || 'AAPL').toUpperCase();
    const mode = args.mode || 'overview';
    let fdData;
    try { fdData = await (await fetch('./sample-fundamentals.json')).json(); } catch(e) { fdData = null; }
    // Fallback inline data
    const revData = { AAPL: [365.8, 394.3, 383.3, 391.0, 420.5], MSFT: [168.1, 198.3, 211.9, 245.1, 277.0], GOOGL: [257.6, 282.8, 307.4, 350.0, 381.0], NVDA: [16.7, 26.9, 60.9, 130.5, 195.0] };
    const years = ['2021', '2022', '2023', '2024', '2025'];
    const revArr = (fdData && fdData[sym] && fdData[sym].revenue) ? fdData[sym].revenue : (revData[sym] || revData.AAPL);
    chart.setOption({
      backgroundColor: B, animation: true,
      title: { text: sym + ' â€” Revenue (Billion USD)', left: 'center', textStyle: { color: T, fontSize: 14, fontWeight: 700 } },
      tooltip: { trigger: 'axis', backgroundColor: '#1e1e3d', borderColor: '#2a2a4a', textStyle: { color: T }, formatter: function(p) { let s = p[0].axisValue + '<br>'; p.forEach(i => { s += `<span style="color:${i.color}">â—</span> Revenue: $${i.value}B<br>`; }); return s; } },
      grid: { left: '10%', right: '4%', top: '14%', bottom: '12%' },
      xAxis: { type: 'category', data: years.slice(0, revArr.length), axisLine: { lineStyle: { color: G } }, axisLabel: { color: S } },
      yAxis: { type: 'value', splitLine: { lineStyle: { color: G } }, axisLabel: { color: S, formatter: v => '$' + v + 'B' } },
      series: [{ name: 'Revenue', type: 'bar', data: revArr, itemStyle: { color: P[0], borderRadius: [4, 4, 0, 0] } }]
    }, true);
    return sym + ' fundamentals rendered (revenue bar chart).';
  }

  if (toolName === 'gainlab_volume_profile') {
    const sym = chatNormSymbol(args.symbol, args.market);
    const tf = args.timeframe || '1d';
    const lim = args.limit || 120;
    const rows = args.rows || 24;
    let r; try { r = await fdata(sym, tf, lim); } catch(e) { throw new Error('Failed to load ' + sym + ' data: ' + e.message); }
    const dt = r.map(k => fd(k[0], tf));
    const oh = r.map(k => [+k[1], +k[4], +k[3], +k[2]]);
    const v = r.map(k => +k[5]);
    const vc = r.map(k => +k[4] >= +k[1] ? U + '80' : D + '80');
    const vp = calcVP(r, rows);
    const maxV = Math.max(...vp.rows.map(r => r.vol));
    const vpPriceMin = vp.rows[0].pMin, vpPriceMax = vp.rows[vp.rows.length - 1].pMax;
    const priceMargin = (vpPriceMax - vpPriceMin) * 0.02;
    chart.setOption({
      backgroundColor: B, animation: false,
      title: { text: sym + ' â€” ' + tf + ' VP', left: 'center', textStyle: { color: T, fontSize: 14, fontWeight: 700 } },
      tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, backgroundColor: '#1e1e3d', borderColor: '#2a2a4a', textStyle: { color: T } },
      grid: [
        { left: '6%', right: '28%', top: '8%', height: '60%' },
        { left: '6%', right: '28%', top: '72%', height: '12%' },
        { left: '74%', right: '2%', top: '8%', height: '60%' }
      ],
      xAxis: [
        { type: 'category', data: dt, gridIndex: 0, axisLine: { lineStyle: { color: G } }, axisLabel: { color: S, fontSize: 9 }, splitLine: { show: false } },
        { type: 'category', data: dt, gridIndex: 1, axisLine: { lineStyle: { color: G } }, axisLabel: { show: false }, splitLine: { show: false } },
        { type: 'value', gridIndex: 2, axisLine: { lineStyle: { color: G } }, axisLabel: { show: false }, splitLine: { show: false }, max: maxV * 1.1 }
      ],
      yAxis: [
        { type: 'value', gridIndex: 0, splitLine: { lineStyle: { color: G } }, axisLabel: { color: S }, min: vpPriceMin - priceMargin, max: vpPriceMax + priceMargin },
        { type: 'value', gridIndex: 1, splitLine: { show: false }, axisLabel: { show: false }, axisLine: { show: false } },
        { type: 'value', gridIndex: 2, axisLine: { lineStyle: { color: G } }, axisLabel: { color: S, fontSize: 7, formatter: v => v.toFixed(0) }, splitLine: { lineStyle: { color: G, opacity: 0.3 } }, min: vpPriceMin - priceMargin, max: vpPriceMax + priceMargin }
      ],
      series: [
        {
          type: 'candlestick', data: oh, xAxisIndex: 0, yAxisIndex: 0,
          itemStyle: { color: U, color0: D, borderColor: U, borderColor0: D },
          markLine: { silent: true, symbol: 'none', lineStyle: { width: 2 }, data: [
            { yAxis: vp.poc, lineStyle: { color: '#ff4757', type: 'solid' }, label: { formatter: 'POC ' + vp.poc.toFixed(2), color: '#ff4757', fontSize: 10, fontWeight: 'bold', position: 'end' } },
            { yAxis: vp.vah, lineStyle: { color: '#ffc233', type: 'dashed' }, label: { formatter: 'VAH ' + vp.vah.toFixed(2), color: '#ffc233', fontSize: 10, position: 'end' } },
            { yAxis: vp.val, lineStyle: { color: '#ffc233', type: 'dashed' }, label: { formatter: 'VAL ' + vp.val.toFixed(2), color: '#ffc233', fontSize: 10, position: 'end' } }
          ]},
          markArea: { silent: true, data: [[{ yAxis: vp.val, itemStyle: { color: '#ffc23315' } }, { yAxis: vp.vah }]] }
        },
        { type: 'bar', data: v.map((x, i) => ({ value: x, itemStyle: { color: vc[i] } })), xAxisIndex: 1, yAxisIndex: 1 },
        {
          name: 'VP', type: 'custom', xAxisIndex: 2, yAxisIndex: 2,
          renderItem: function(params, api) {
            const idx = params.dataIndex; const row = vp.rows[idx]; if (!row) return;
            const buyV = row.bv, sellV = row.sv;
            const yBottom = api.coord([0, row.pMin])[1]; const yTop = api.coord([0, row.pMax])[1];
            const xBuyEnd = api.coord([buyV, 0])[0]; const xSellEnd = api.coord([buyV + sellV, 0])[0];
            const xOrigin = api.coord([0, 0])[0]; const isPOC = idx === vp.pocIdx;
            const group = { type: 'group', children: [] };
            if (buyV > 0) group.children.push({ type: 'rect', shape: { x: xOrigin, y: yTop, width: xBuyEnd - xOrigin, height: yBottom - yTop }, style: { fill: isPOC ? '#fff' : U, stroke: isPOC ? '#fff' : 'transparent', lineWidth: isPOC ? 2 : 0 } });
            if (sellV > 0) group.children.push({ type: 'rect', shape: { x: xBuyEnd, y: yTop, width: xSellEnd - xBuyEnd, height: yBottom - yTop }, style: { fill: isPOC ? '#ccc' : D, stroke: isPOC ? '#fff' : 'transparent', lineWidth: isPOC ? 2 : 0 } });
            return group;
          },
          data: vp.rows.map(row => [row.bv + row.sv, row.pMid])
        }
      ],
      dataZoom: [{ type: 'inside', xAxisIndex: [0, 1] }]
    }, true);
    return sym + ' Volume Profile rendered. POC: ' + vp.poc.toFixed(2) + ' | VAH: ' + vp.vah.toFixed(2) + ' | VAL: ' + vp.val.toFixed(2);
  }

  if (toolName === 'gainlab_heatmap') {
    const market = args.market || 'crypto';
    const lim = args.limit || 50;
    const minV = args.min_volume || 1000000;
    let res; try { res = await (await fetch('https://api.binance.com/api/v3/ticker/24hr')).json(); } catch(e) { throw new Error('Failed to fetch Binance data: ' + e.message); }
    let items = res.filter(t => {
      if (!t.symbol.endsWith('USDT')) return false;
      const b = cBase(t.symbol); if (EXCL.has(b)) return false;
      return parseFloat(t.quoteVolume || '0') >= minV;
    }).map(t => {
      const b = cBase(t.symbol);
      return { code: b, chg: parseFloat(t.priceChangePercent || '0'), vol: parseFloat(t.quoteVolume || '0'), price: parseFloat(t.lastPrice || '0'), sector: CSEC[b] || 'Other' };
    }).sort((a, b) => b.vol - a.vol).slice(0, lim);
    const sm = new Map();
    items.forEach(i => { if (!sm.has(i.sector)) sm.set(i.sector, []); sm.get(i.sector).push(i); });
    const tree = [...sm.entries()].map(([sec, stocks]) => ({
      name: sec,
      children: stocks.map(s => ({ name: s.code, value: s.vol, itemStyle: { color: cChg(s.chg), borderColor: B, borderWidth: 1 }, _d: { price: s.price, chg: s.chg, vol: s.vol, sector: s.sector } }))
    }));
    chart.setOption({
      backgroundColor: B,
      title: { text: 'Crypto Sector Heatmap (24h Change)', left: 'center', top: 8, textStyle: { color: T, fontSize: 14, fontWeight: 700 } },
      tooltip: { formatter: i => { const d = i.data?._d; if (!d) return '<b>' + i.name + '</b>'; const s = d.chg >= 0 ? '+' : ''; return `<b>${i.name}</b><br>Price: $${d.price.toLocaleString()}<br>Change: <span style="color:${d.chg >= 0 ? U : D}">${s}${d.chg.toFixed(2)}%</span><br>24h Vol: $${(d.vol / 1e6).toFixed(1)}M<br>${d.sector}`; } },
      series: [{
        type: 'treemap', data: tree, width: '94%', height: '84%', top: 44, left: 'center', roam: false, nodeClick: false, breadcrumb: { show: false },
        levels: [
          { itemStyle: { borderColor: '#333', borderWidth: 0, gapWidth: 2 } },
          { itemStyle: { borderColor: '#555', borderWidth: 2, gapWidth: 2 }, upperLabel: { show: true, height: 20, color: S, fontSize: 11, fontWeight: 'bold', backgroundColor: 'transparent' } },
          { itemStyle: { borderColor: B, borderWidth: 1, gapWidth: 1 }, label: { show: true, formatter: p => { const d = p.data?._d; if (!d) return p.name; const s = d.chg >= 0 ? '+' : ''; return '{name|' + p.name + '}\n{chg|' + s + d.chg.toFixed(1) + '%}'; }, rich: { name: { fontSize: 12, color: '#fff', fontWeight: 'bold', lineHeight: 16 }, chg: { fontSize: 10, color: '#ddd', lineHeight: 14 } }, align: 'center', verticalAlign: 'middle' } }
        ]
      }]
    }, true);
    return 'Crypto heatmap rendered: ' + items.length + ' tokens, ' + sm.size + ' sectors.';
  }

  if (toolName === 'gainlab_wrb_scoring') {
    const sym = chatNormSymbol(args.symbol, args.market);
    const tf = args.timeframe || '1d';
    const lim = args.limit || 150;
    let r; try { r = await fdata(sym, tf, lim); } catch(e) { throw new Error('Failed to load ' + sym + ' data: ' + e.message); }
    const dt = r.map(k => fd(k[0], tf));
    const oh = r.map(k => [+k[1], +k[4], +k[3], +k[2]]);
    const v = r.map(k => +k[5]);
    const vc = r.map(k => +k[4] >= +k[1] ? U + '80' : D + '80');
    const w = detectWRB(r);
    const wrbMark = w.wrb.map(x => ({
      coord: [dt[x.idx], x.bull ? w.bars[x.idx].h * 1.008 : w.bars[x.idx].l * 0.992],
      symbol: 'diamond', symbolSize: 10,
      itemStyle: { color: '#7c4dff' },
      label: { show: true, formatter: x.bull ? 'æ¶¨' : 'è·Œ', color: x.bull ? U : D, fontSize: 9, fontWeight: 'bold', position: x.bull ? 'top' : 'bottom', offset: [0, x.bull ? -2 : 2] }
    }));
    const gapAreas = w.gaps.filter(g => !g.filled).map(g => {
      const color = g.pro ? '#ffc23335' : (g.bull ? '#00d4aa25' : '#ff475725');
      return [{ xAxis: dt[g.idx], yAxis: g.top, itemStyle: { color } }, { xAxis: dt[dt.length - 1], yAxis: g.bot }];
    });
    const proData = w.gaps.filter(g => g.pro && !g.filled).map(g => ({ value: [dt[g.idx], g.bull ? w.bars[g.idx].l * 0.996 : w.bars[g.idx].h * 1.004] }));
    chart.setOption({
      backgroundColor: B, animation: false,
      title: { text: sym + ' â€” ' + tf + ' WRB/HG', left: 'center', textStyle: { color: T, fontSize: 14, fontWeight: 700 } },
      tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, backgroundColor: '#1e1e3d', borderColor: '#2a2a4a', textStyle: { color: T } },
      legend: { data: ['Pro Signal'], bottom: 4, right: 16, textStyle: { color: S, fontSize: 10 } },
      grid: [{ left: '8%', right: '4%', top: '10%', height: '54%' }, { left: '8%', right: '4%', top: '68%', height: '14%' }],
      xAxis: [
        { type: 'category', data: dt, gridIndex: 0, axisLine: { lineStyle: { color: G } }, axisLabel: { color: S, fontSize: 9 }, splitLine: { show: false } },
        { type: 'category', data: dt, gridIndex: 1, axisLine: { lineStyle: { color: G } }, axisLabel: { show: false }, splitLine: { show: false } }
      ],
      yAxis: [
        { type: 'value', gridIndex: 0, splitLine: { lineStyle: { color: G } }, axisLabel: { color: S }, scale: true },
        { type: 'value', gridIndex: 1, splitLine: { show: false }, axisLabel: { show: false }, axisLine: { show: false } }
      ],
      series: [
        {
          type: 'candlestick', data: oh, itemStyle: { color: U, color0: D, borderColor: U, borderColor0: D },
          markPoint: { data: wrbMark, animation: false },
          markArea: { silent: true, data: gapAreas }
        },
        { name: 'Pro Signal', type: 'scatter', data: proData, symbol: 'diamond', symbolSize: 14, itemStyle: { color: '#ffc233', borderColor: '#fff', borderWidth: 2 }, z: 10 },
        { type: 'bar', data: v.map((x, i) => ({ value: x, itemStyle: { color: vc[i] } })), xAxisIndex: 1, yAxisIndex: 1 }
      ],
      dataZoom: [{ type: 'inside', xAxisIndex: [0, 1] }]
    }, true);
    const activeG = w.gaps.filter(g => !g.filled).length, proG = w.gaps.filter(g => g.pro && !g.filled).length;
    return sym + ' WRB/HG analysis rendered. WRB: ' + w.wrb.length + ' | Active gaps: ' + activeG + ' | Pro signals: ' + proG;
  }

  throw new Error('Unknown tool: ' + toolName);
}

// Init chat panel on first show: insert welcome message + populate toolbar
function initChatPanel() {
  const msgsEl = document.getElementById('chat-messages');
  if (!msgsEl || msgsEl.dataset.inited) return;
  msgsEl.dataset.inited = '1';
  chatAddMsg('ai', t('chat_welcome'));
  // Populate toolbar symbol dropdown
  chatToolbarUpdateSymbols();
}

// Extend sw() to init chat on first visit
// (Note: sw is a function declaration; we wrap it via an outer variable)
const _swOrig = sw;
// Redefine sw via variable assignment to avoid hoisting conflict
// eslint-disable-next-line no-func-assign
sw = function(n, el) {
  _swOrig(n, el);
  if (n === 'chat') {
    initChatPanel();
    setTimeout(() => { if (ch['c-chat-main']) ch['c-chat-main'].resize(); }, 100);
  }
};

// Extend setLang to update chat placeholder
const _setLangOrig = setLang;
setLang = function(lang) {
  _setLangOrig(lang);
  const inp = document.getElementById('chat-input');
  if (inp) inp.placeholder = t('chat_placeholder');
  const btn = document.getElementById('chat-send-btn');
  if (btn) btn.textContent = t('chat_send');
};
</script>
</body>
</html>
